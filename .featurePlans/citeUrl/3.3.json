{
  "id": "3.3",
  "title": "Implement Authority Grouping",
  "objective": "Create Authority record and grouping logic to collect citations to the same legal source",
  "complexity": "moderate",
  "phaseId": "3",
  "taskNumber": 3,
  "totalTasksInPhase": 3,

  "metadata": {
    "taskType": "implementation",
    "estimatedDuration": "4-5 hours",
    "dependencies": ["3.2"],
    "skillLevel": "intermediate-advanced"
  },

  "contextManagement": {
    "isFirstInPhase": false,
    "isLastInPhase": true,
    "phaseBoundaryInstructions": "**PHASE 3 COMPLETE** - Create ingestion_phaseBoundary_phase3_[timestamp].md with citation finding examples and readiness for Phase 4. **MANDATORY STOP** for user approval."
  },

  "criticalAnchors": [
    "IMMUTABLE: Authority is record class (immutable)",
    "IMMUTABLE: Authorities group by core tokens (ignore pincites/subsections)",
    "IMMUTABLE: Sorted by citation count (most cited first)",
    "IMMUTABLE: ListAuthorities() returns IEnumerable<Authority> (streaming)"
  ],

  "agentInstructions": "## Task 3.3: Implement Authority Grouping\n\n### Step 1: Create Authority Record\n\n**Create `src/CiteUrl.Core/Models/Authority.cs`:**\n\n```csharp\nusing System.Collections.Immutable;\nusing CiteUrl.Core.Templates;\nusing CiteUrl.Core.Tokens;\n\nnamespace CiteUrl.Core.Models;\n\npublic record class Authority\n{\n    public Template Template { get; init; } = null!;\n    public ImmutableDictionary<string, string> Tokens { get; init; } = ImmutableDictionary<string, string>.Empty;\n    public List<Citation> Citations { get; init; } = new();\n    public IReadOnlyList<string> IgnoredTokens { get; init; } = Array.Empty<string>();\n\n    public string? Url => Template.UrlBuilder?.Build(Tokens.ToDictionary(k => k.Key, v => v.Value));\n    public string? Name => Template.NameBuilder?.Build(Tokens.ToDictionary(k => k.Key, v => v.Value)) \n        ?? DeriveName();\n\n    private string? DeriveName()\n    {\n        var first = Citations.FirstOrDefault(c => c.Parent == null);\n        return first?.Name ?? first?.Text;\n    }\n\n    public bool Contains(Citation citation)\n    {\n        if (citation.Template.Name != Template.Name)\n            return false;\n\n        foreach (var (tokenName, tokenValue) in Tokens)\n        {\n            if (!citation.Tokens.TryGetValue(tokenName, out var citationValue))\n                return false;\n\n            var tokenType = Template.Tokens[tokenName];\n            if (tokenType.IsSeverable)\n            {\n                if (!citationValue.StartsWith(tokenValue))\n                    return false;\n            }\n            else if (citationValue != tokenValue)\n            {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n```\n\n### Step 2: Add ListAuthorities to ICitator and Citator\n\n**Update `src/CiteUrl.Core/Templates/ICitator.cs`:**\n\n```csharp\nIEnumerable<Authority> ListAuthorities(IEnumerable<Citation> citations, \n    IEnumerable<string>? ignoredTokens = null, bool sortByCites = true);\n```\n\n**Add to `Citator.cs`:**\n\n```csharp\npublic IEnumerable<Authority> ListAuthorities(IEnumerable<Citation> citations,\n    IEnumerable<string>? ignoredTokens = null, bool sortByCites = true)\n{\n    var ignored = ignoredTokens?.ToHashSet() ?? new HashSet<string>();\n    var authorities = new List<Authority>();\n\n    foreach (var citation in citations)\n    {\n        var coreTokens = citation.Tokens\n            .Where(kv => !ignored.Contains(kv.Key))\n            .Where(kv => !citation.Template.Tokens[kv.Key].IsSeverable || \n                         citation.Parent == null)\n            .ToImmutableDictionary();\n\n        var existing = authorities.FirstOrDefault(a => \n            a.Template.Name == citation.Template.Name && \n            a.Tokens.SequenceEqual(coreTokens));\n\n        if (existing != null)\n        {\n            existing.Citations.Add(citation);\n        }\n        else\n        {\n            authorities.Add(new Authority\n            {\n                Template = citation.Template,\n                Tokens = coreTokens,\n                Citations = new List<Citation> { citation },\n                IgnoredTokens = ignored.ToArray()\n            });\n        }\n    }\n\n    if (sortByCites)\n    {\n        authorities = authorities.OrderByDescending(a => a.Citations.Count).ToList();\n    }\n\n    return authorities;\n}\n\npublic static IEnumerable<Authority> ListAuthorities(string text, ICitator? citator = null, \n    IEnumerable<string>? ignoredTokens = null)\n{\n    var c = citator ?? Default;\n    var citations = c.ListCitations(text);\n    return c.ListAuthorities(citations, ignoredTokens);\n}\n```\n\n### Step 3: Create Tests\n\n**Create `tests/CiteUrl.Core.Tests/Models/AuthorityTests.cs`:**\n\n```csharp\nusing CiteUrl.Core.Models;\nusing CiteUrl.Core.Templates;\nusing Shouldly;\nusing Xunit;\n\npublic class AuthorityTests\n{\n    [Fact]\n    public void ListAuthorities_GroupsByCoreTokens()\n    {\n        var text = \"See 42 U.S.C. ยง 1983 and ยง 1985. Also 42 U.S.C. ยง 1983.\";\n        var authorities = Citator.ListAuthorities(text).ToList();\n        \n        authorities.Count.ShouldBeGreaterThanOrEqualTo(1);\n    }\n\n    [Fact]\n    public void ListAuthorities_SortsByCitationCount()\n    {\n        var text = \"42 USC 1983, 1983 again, and 1985 once.\";\n        var authorities = Citator.ListAuthorities(text).ToList();\n        \n        if (authorities.Count >= 2)\n        {\n            authorities[0].Citations.Count.ShouldBeGreaterThanOrEqualTo(\n                authorities[1].Citations.Count);\n        }\n    }\n}\n```\n\n### Step 4: Create Phase 3 Boundary Summary\n\n**Create `.featurePlans/CiteUrl/ingestion_phaseBoundary_phase3_[timestamp].md`**\n\n### Verification\n- [ ] Authority record created\n- [ ] Citation grouping works\n- [ ] Severable token matching\n- [ ] Sorting by citation count\n- [ ] Name derivation works\n- [ ] Phase boundary summary created\n- [ ] All tests pass (60+ total)",

  "successCriteria": [
    "Authority record class created",
    "ListAuthorities() groups citations correctly",
    "Severable token matching works (prefix match)",
    "Authorities sorted by citation count",
    "Name derivation works without NameBuilder",
    "All 5+ Authority tests pass",
    "Phase 3 boundary summary created"
  ],

  "associatedArtifacts": [
    {
      "type": "source_file",
      "path": "src/CiteUrl.Core/Models/Authority.cs",
      "description": "Authority record for grouping citations"
    },
    {
      "type": "test_file",
      "path": "tests/CiteUrl.Core.Tests/Models/AuthorityTests.cs",
      "description": "Authority tests"
    },
    {
      "type": "phase_boundary",
      "path": ".featurePlans/CiteUrl/ingestion_phaseBoundary_phase3_[timestamp].md",
      "description": "Phase 3 completion summary"
    }
  ]
}
