{
  "id": "2.1",
  "title": "Implement Template Class",
  "objective": "Create Template class with regex compilation, token management, pattern processing with replacements, and template inheritance support",
  "complexity": "complex",
  "phaseId": "2",
  "taskNumber": 1,
  "totalTasksInPhase": 3,

  "metadata": {
    "taskType": "implementation",
    "estimatedDuration": "6-8 hours",
    "dependencies": ["1.1", "1.2", "1.3"],
    "requiredContext": [
      "Phase 1 completion summary",
      "TokenType and StringBuilder from Phase 1",
      "Regex timeout decision from gap analysis"
    ],
    "skillLevel": "advanced"
  },

  "contextManagement": {
    "isFirstInPhase": true,
    "isLastInPhase": false,
    "requiredContext": [
      "Phase 1 boundary summary (token system complete)",
      "TokenType and TokenOperation classes",
      "StringBuilder class",
      "Gap decision: 1-second regex timeout default"
    ],
    "contextToPreserve": [
      "Template class with compiled regexes",
      "Pattern replacement logic (${token} → (?P<token>REGEX))",
      "Template inheritance mechanism",
      "Broad vs. normal regex distinction"
    ]
  },

  "criticalAnchors": [
    "IMMUTABLE: Regexes compiled once at construction with RegexOptions.Compiled",
    "IMMUTABLE: Template regexes include 1-second matchTimeout (Gap Decision #4)",
    "IMMUTABLE: Template inheritance supported via override-based merging",
    "IMMUTABLE: Separate regex sets for broad vs. normal matching",
    "IMMUTABLE: Shortform/idform patterns stored as strings (compiled per-citation)",
    "IMMUTABLE: Pattern replacement: {token_name} → (?P<token_name>TOKEN_REGEX)(?!\\w)",
    "IMMUTABLE: Add word boundaries: (?<!\\w)PATTERN(?!\\w)"
  ],

  "agentInstructions": "## Task 2.1: Implement Template Class\n\n### Overview\nYou will create the Template class that manages citation pattern matching with compiled regexes, token dictionaries, and template inheritance.\n\n### Step-by-Step Instructions\n\n#### STEP 1: Create Template Class\n\n**Create `src/CiteUrl.Core/Templates/Template.cs`:**\n\n```csharp\nusing System.Collections.Immutable;\nusing System.Text.RegularExpressions;\nusing CiteUrl.Core.Tokens;\nusing CiteUrl.Core.Models;\n\nnamespace CiteUrl.Core.Templates;\n\n/// <summary>\n/// Represents a citation template with compiled regex patterns and token definitions.\n/// Templates are immutable after construction for thread safety.\n/// </summary>\npublic class Template\n{\n    /// <summary>\n    /// The unique name of this template (e.g., \"U.S. Code\").\n    /// </summary>\n    public string Name { get; init; } = string.Empty;\n\n    /// <summary>\n    /// Ordered dictionary of token names to token definitions.\n    /// Order matters for pattern replacement.\n    /// </summary>\n    public ImmutableDictionary<string, TokenType> Tokens { get; init; } = \n        ImmutableDictionary<string, TokenType>.Empty;\n\n    /// <summary>\n    /// Metadata key-value pairs (used for StringBuilder defaults, pattern replacements).\n    /// </summary>\n    public ImmutableDictionary<string, string> Metadata { get; init; } = \n        ImmutableDictionary<string, string>.Empty;\n\n    /// <summary>\n    /// Compiled regex patterns for normal (narrow) matching.\n    /// Case-sensitive, precise patterns.\n    /// </summary>\n    public ImmutableList<Regex> Regexes { get; init; } = ImmutableList<Regex>.Empty;\n\n    /// <summary>\n    /// Compiled regex patterns for broad matching.\n    /// Case-insensitive, more lenient patterns for better recall.\n    /// </summary>\n    public ImmutableList<Regex> BroadRegexes { get; init; } = ImmutableList<Regex>.Empty;\n\n    /// <summary>\n    /// Processed shortform pattern strings with token replacements applied.\n    /// Compiled per-citation instance, not globally.\n    /// </summary>\n    public ImmutableList<string> ProcessedShortformPatterns { get; init; } = \n        ImmutableList<string>.Empty;\n\n    /// <summary>\n    /// Processed idform pattern strings with token replacements applied.\n    /// Compiled per-citation instance, not globally.\n    /// </summary>\n    public ImmutableList<string> ProcessedIdformPatterns { get; init; } = \n        ImmutableList<string>.Empty;\n\n    /// <summary>\n    /// StringBuilder for constructing URLs from citation tokens.\n    /// </summary>\n    public CiteUrl.Core.Tokens.StringBuilder? UrlBuilder { get; init; }\n\n    /// <summary>\n    /// StringBuilder for constructing display names from citation tokens.\n    /// </summary>\n    public CiteUrl.Core.Tokens.StringBuilder? NameBuilder { get; init; }\n\n    /// <summary>\n    /// Regex timeout for pattern matching (default: 1 second).\n    /// </summary>\n    public TimeSpan RegexTimeout { get; init; } = TimeSpan.FromSeconds(1);\n\n    /// <summary>\n    /// Constructor that processes patterns and compiles regexes.\n    /// </summary>\n    /// <param name=\"name\">Template name</param>\n    /// <param name=\"tokens\">Token dictionary</param>\n    /// <param name=\"metadata\">Metadata dictionary</param>\n    /// <param name=\"patterns\">Normal pattern strings</param>\n    /// <param name=\"broadPatterns\">Broad pattern strings</param>\n    /// <param name=\"shortformPatterns\">Shortform pattern strings</param>\n    /// <param name=\"idformPatterns\">Idform pattern strings</param>\n    /// <param name=\"urlBuilder\">URL builder</param>\n    /// <param name=\"nameBuilder\">Name builder</param>\n    /// <param name=\"regexTimeout\">Regex match timeout</param>\n    public Template(\n        string name,\n        ImmutableDictionary<string, TokenType> tokens,\n        ImmutableDictionary<string, string> metadata,\n        IEnumerable<string> patterns,\n        IEnumerable<string> broadPatterns,\n        IEnumerable<string> shortformPatterns,\n        IEnumerable<string> idformPatterns,\n        CiteUrl.Core.Tokens.StringBuilder? urlBuilder,\n        CiteUrl.Core.Tokens.StringBuilder? nameBuilder,\n        TimeSpan? regexTimeout = null)\n    {\n        Name = name;\n        Tokens = tokens;\n        Metadata = metadata;\n        UrlBuilder = urlBuilder;\n        NameBuilder = nameBuilder;\n        RegexTimeout = regexTimeout ?? TimeSpan.FromSeconds(1);\n\n        // Build replacement dictionary from metadata + tokens\n        var replacements = BuildReplacementDictionary();\n\n        // Process and compile normal patterns\n        Regexes = patterns\n            .Select(p => ProcessPattern(p, replacements))\n            .Select(p => new Regex(p, RegexOptions.Compiled, RegexTimeout))\n            .ToImmutableList();\n\n        // Process and compile broad patterns (case-insensitive)\n        BroadRegexes = broadPatterns\n            .Select(p => ProcessPattern(p, replacements))\n            .Select(p => new Regex(p, RegexOptions.Compiled | RegexOptions.IgnoreCase, RegexTimeout))\n            .ToImmutableList();\n\n        // Process shortform/idform patterns (NOT compiled here)\n        ProcessedShortformPatterns = shortformPatterns\n            .Select(p => ProcessPattern(p, replacements))\n            .ToImmutableList();\n\n        ProcessedIdformPatterns = idformPatterns\n            .Select(p => ProcessPattern(p, replacements))\n            .ToImmutableList();\n    }\n\n    /// <summary>\n    /// Builds a dictionary of {placeholder} → replacement values\n    /// from metadata and token regex patterns.\n    /// </summary>\n    private ImmutableDictionary<string, string> BuildReplacementDictionary()\n    {\n        var dict = new Dictionary<string, string>(Metadata);\n\n        // Add token regex patterns\n        foreach (var (tokenName, tokenType) in Tokens)\n        {\n            dict[tokenName] = tokenType.Regex;\n        }\n\n        return dict.ToImmutableDictionary();\n    }\n\n    /// <summary>\n    /// Processes a pattern string by:\n    /// 1. Replacing {token_name} with (?P&lt;token_name&gt;TOKEN_REGEX)(?!\\w)\n    /// 2. Replacing metadata placeholders\n    /// 3. Adding word boundaries\n    /// </summary>\n    private string ProcessPattern(string pattern, ImmutableDictionary<string, string> replacements)\n    {\n        var result = pattern;\n\n        // Replace {token} with (?P<token>REGEX)(?!\\w)\n        var tokenPattern = new Regex(@\"\\{([^}]+)\\}\");\n        result = tokenPattern.Replace(result, match =>\n        {\n            var tokenName = match.Groups[1].Value;\n            \n            if (replacements.TryGetValue(tokenName, out var regex))\n            {\n                // Use .NET named group syntax\n                return $\"(?<{tokenName}>{regex})(?!\\\\w)\";\n            }\n            \n            // If not found in replacements, leave as-is\n            return match.Value;\n        });\n\n        // Add word boundaries at start and end\n        result = $@\"(?<!\\w){result}(?!\\w)\";\n\n        return result;\n    }\n\n    /// <summary>\n    /// Creates a Template by inheriting from a parent template.\n    /// Child properties override parent properties.\n    /// </summary>\n    public static Template Inherit(\n        Template parent,\n        string? name = null,\n        ImmutableDictionary<string, TokenType>? tokens = null,\n        ImmutableDictionary<string, string>? metadata = null,\n        IEnumerable<string>? patterns = null,\n        IEnumerable<string>? broadPatterns = null,\n        IEnumerable<string>? shortformPatterns = null,\n        IEnumerable<string>? idformPatterns = null,\n        CiteUrl.Core.Tokens.StringBuilder? urlBuilder = null,\n        CiteUrl.Core.Tokens.StringBuilder? nameBuilder = null)\n    {\n        // Merge tokens (child overrides parent)\n        var mergedTokens = parent.Tokens;\n        if (tokens != null)\n        {\n            mergedTokens = mergedTokens.SetItems(tokens);\n        }\n\n        // Merge metadata (child overrides parent)\n        var mergedMetadata = parent.Metadata;\n        if (metadata != null)\n        {\n            mergedMetadata = mergedMetadata.SetItems(metadata);\n        }\n\n        // Update StringBuilder defaults if metadata changed\n        var mergedUrlBuilder = urlBuilder ?? parent.UrlBuilder;\n        var mergedNameBuilder = nameBuilder ?? parent.NameBuilder;\n\n        return new Template(\n            name: name ?? parent.Name,\n            tokens: mergedTokens,\n            metadata: mergedMetadata,\n            patterns: patterns ?? Array.Empty<string>(),\n            broadPatterns: broadPatterns ?? Array.Empty<string>(),\n            shortformPatterns: shortformPatterns ?? Array.Empty<string>(),\n            idformPatterns: idformPatterns ?? Array.Empty<string>(),\n            urlBuilder: mergedUrlBuilder,\n            nameBuilder: mergedNameBuilder,\n            regexTimeout: parent.RegexTimeout\n        );\n    }\n}\n```\n\n#### STEP 2: Create Unit Tests\n\n**Create `tests/CiteUrl.Core.Tests/Templates/TemplateTests.cs`:**\n\n```csharp\nusing System.Collections.Immutable;\nusing System.Text.RegularExpressions;\nusing CiteUrl.Core.Templates;\nusing CiteUrl.Core.Tokens;\nusing Shouldly;\nusing Xunit;\n\nnamespace CiteUrl.Core.Tests.Templates;\n\npublic class TemplateTests\n{\n    [Fact]\n    public void Constructor_CompilesRegexesWithTimeout()\n    {\n        // Arrange & Act\n        var template = new Template(\n            name: \"Test Template\",\n            tokens: ImmutableDictionary<string, TokenType>.Empty,\n            metadata: ImmutableDictionary<string, string>.Empty,\n            patterns: new[] { @\"\\d+\" },\n            broadPatterns: Array.Empty<string>(),\n            shortformPatterns: Array.Empty<string>(),\n            idformPatterns: Array.Empty<string>(),\n            urlBuilder: null,\n            nameBuilder: null,\n            regexTimeout: TimeSpan.FromSeconds(1)\n        );\n\n        // Assert\n        template.Regexes.Count.ShouldBe(1);\n        template.RegexTimeout.ShouldBe(TimeSpan.FromSeconds(1));\n    }\n\n    [Fact]\n    public void Constructor_ProcessesTokenReplacements()\n    {\n        // Arrange\n        var tokens = ImmutableDictionary<string, TokenType>.Empty\n            .Add(\"title\", new TokenType { Regex = @\"\\d+\" })\n            .Add(\"section\", new TokenType { Regex = @\"\\d+\\w*\" });\n\n        // Act\n        var template = new Template(\n            name: \"USC\",\n            tokens: tokens,\n            metadata: ImmutableDictionary<string, string>.Empty,\n            patterns: new[] { @\"{title} U\\.S\\.C\\. § {section}\" },\n            broadPatterns: Array.Empty<string>(),\n            shortformPatterns: Array.Empty<string>(),\n            idformPatterns: Array.Empty<string>(),\n            urlBuilder: null,\n            nameBuilder: null\n        );\n\n        // Assert\n        template.Regexes.Count.ShouldBe(1);\n        \n        // Test the regex matches expected input\n        var match = template.Regexes[0].Match(\"42 U.S.C. § 1983\");\n        match.Success.ShouldBeTrue();\n        match.Groups[\"title\"].Value.ShouldBe(\"42\");\n        match.Groups[\"section\"].Value.ShouldBe(\"1983\");\n    }\n\n    [Fact]\n    public void BroadRegexes_AreCaseInsensitive()\n    {\n        // Arrange & Act\n        var template = new Template(\n            name: \"Test\",\n            tokens: ImmutableDictionary<string, TokenType>.Empty,\n            metadata: ImmutableDictionary<string, string>.Empty,\n            patterns: Array.Empty<string>(),\n            broadPatterns: new[] { \"section\" },\n            shortformPatterns: Array.Empty<string>(),\n            idformPatterns: Array.Empty<string>(),\n            urlBuilder: null,\n            nameBuilder: null\n        );\n\n        // Assert\n        var regex = template.BroadRegexes[0];\n        regex.IsMatch(\"Section\").ShouldBeTrue();\n        regex.IsMatch(\"SECTION\").ShouldBeTrue();\n        regex.IsMatch(\"section\").ShouldBeTrue();\n    }\n\n    [Fact]\n    public void Inherit_MergesParentAndChildTokens()\n    {\n        // Arrange\n        var parentTokens = ImmutableDictionary<string, TokenType>.Empty\n            .Add(\"token1\", new TokenType { Regex = \"parent1\" })\n            .Add(\"token2\", new TokenType { Regex = \"parent2\" });\n\n        var parent = new Template(\n            name: \"Parent\",\n            tokens: parentTokens,\n            metadata: ImmutableDictionary<string, string>.Empty,\n            patterns: Array.Empty<string>(),\n            broadPatterns: Array.Empty<string>(),\n            shortformPatterns: Array.Empty<string>(),\n            idformPatterns: Array.Empty<string>(),\n            urlBuilder: null,\n            nameBuilder: null\n        );\n\n        var childTokens = ImmutableDictionary<string, TokenType>.Empty\n            .Add(\"token2\", new TokenType { Regex = \"child2\" })  // Override\n            .Add(\"token3\", new TokenType { Regex = \"child3\" }); // New\n\n        // Act\n        var child = Template.Inherit(\n            parent,\n            name: \"Child\",\n            tokens: childTokens\n        );\n\n        // Assert\n        child.Tokens.Count.ShouldBe(3);\n        child.Tokens[\"token1\"].Regex.ShouldBe(\"parent1\"); // Inherited\n        child.Tokens[\"token2\"].Regex.ShouldBe(\"child2\"); // Overridden\n        child.Tokens[\"token3\"].Regex.ShouldBe(\"child3\"); // New\n    }\n\n    [Fact]\n    public void Inherit_MergesMetadata()\n    {\n        // Arrange\n        var parentMeta = ImmutableDictionary<string, string>.Empty\n            .Add(\"base_url\", \"https://parent.com\")\n            .Add(\"key1\", \"parent\");\n\n        var parent = new Template(\n            name: \"Parent\",\n            tokens: ImmutableDictionary<string, TokenType>.Empty,\n            metadata: parentMeta,\n            patterns: Array.Empty<string>(),\n            broadPatterns: Array.Empty<string>(),\n            shortformPatterns: Array.Empty<string>(),\n            idformPatterns: Array.Empty<string>(),\n            urlBuilder: null,\n            nameBuilder: null\n        );\n\n        var childMeta = ImmutableDictionary<string, string>.Empty\n            .Add(\"key1\", \"child\");  // Override\n\n        // Act\n        var child = Template.Inherit(parent, metadata: childMeta);\n\n        // Assert\n        child.Metadata[\"base_url\"].ShouldBe(\"https://parent.com\"); // Inherited\n        child.Metadata[\"key1\"].ShouldBe(\"child\"); // Overridden\n    }\n}\n```\n\n#### STEP 3: Build and Run Tests\n\n```bash\ndotnet build\ndotnet test --verbosity normal\n```\n\nVerify all tests pass.\n\n### Verification Checklist\n- [ ] Template regexes compile without errors\n- [ ] Regex timeout set to 1 second by default\n- [ ] Pattern replacement logic works ({token} → regex groups)\n- [ ] Template inheritance merges tokens and metadata\n- [ ] Broad regexes are case-insensitive\n- [ ] Can match sample citations with compiled regexes\n- [ ] All unit tests pass (5+ new tests)\n\n### Post-Task Actions\nNone - proceed to Task 2.2",

  "successCriteria": [
    "Template class created with immutable collections (ImmutableDictionary, ImmutableList)",
    "Regexes compiled at construction with RegexOptions.Compiled",
    "Regex timeout defaults to 1 second (Gap Decision #4)",
    "Pattern processing replaces {token} with named groups correctly",
    "Template.Inherit() merges parent and child properties correctly",
    "Broad regexes use RegexOptions.IgnoreCase",
    "Shortform/idform patterns stored as processed strings (not compiled)",
    "All 5+ Template tests pass",
    "Template can successfully match simple citation patterns"
  ],

  "pauseAndAskScenarios": [
    "If regex pattern replacement produces invalid regex syntax",
    "If template inheritance merge strategy needs clarification"
  ],

  "executionControls": {
    "scopeAndBoundaries": {
      "mustImplement": [
        "Immutable collections for thread safety",
        "Regex compilation with 1-second timeout",
        "Pattern replacement with {token} syntax",
        "Template inheritance via Inherit() method",
        "Separate normal and broad regex lists",
        "Word boundary addition to patterns"
      ],
      "mustNotImplement": [
        "Do not compile shortform/idform patterns at template level",
        "Do not use mutable collections",
        "Do not skip regex timeout parameter"
      ],
      "flexible": [
        "Internal method names for pattern processing",
        "Exact word boundary regex syntax",
        "Test organization"
      ]
    },
    "riskFactors": [
      {
        "risk": "Pattern replacement could produce invalid regex",
        "mitigation": "Test with real citation patterns, catch regex compilation exceptions",
        "severity": "high"
      },
      {
        "risk": "Regex timeout may be too short for complex patterns",
        "mitigation": "Make timeout configurable, default to 1 second as decided",
        "severity": "medium"
      }
    ],
    "qualityGates": [
      "All tests must pass",
      "Regex compilation must succeed for sample patterns",
      "Template inheritance must preserve all parent data"
    ]
  },

  "associatedArtifacts": [
    {
      "type": "source_file",
      "path": "src/CiteUrl.Core/Templates/Template.cs",
      "description": "Template class with regex compilation and pattern processing"
    },
    {
      "type": "test_file",
      "path": "tests/CiteUrl.Core.Tests/Templates/TemplateTests.cs",
      "description": "Unit tests for Template class functionality"
    }
  ]
}
