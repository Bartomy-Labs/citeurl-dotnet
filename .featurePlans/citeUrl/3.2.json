{
  "id": "3.2",
  "title": "Implement Citator Class and ICitator Interface",
  "objective": "Create main Citator orchestrator with ICitator interface, template management, citation finding methods, and streaming enumeration (Gap Decision #6)",
  "complexity": "very-complex",
  "phaseId": "3",
  "taskNumber": 2,
  "totalTasksInPhase": 3,

  "metadata": {
    "taskType": "implementation",
    "estimatedDuration": "8-10 hours",
    "dependencies": ["3.1"],
    "requiredContext": [
      "Citation record from Task 3.1",
      "Template system from Phase 2",
      "Gap Decision #2: Thread-safe immutable design",
      "Gap Decision #3: ICitator interface for DI",
      "Gap Decision #6: Streaming IEnumerable returns"
    ],
    "skillLevel": "advanced"
  },

  "contextManagement": {
    "isFirstInPhase": false,
    "isLastInPhase": false,
    "requiredContext": [
      "Citation.FromMatch() from Task 3.1",
      "Template.Regexes and BroadRegexes",
      "ResourceLoader.LoadAllDefaultYaml()",
      "Gap decisions on threading, DI, and streaming"
    ],
    "contextToPreserve": [
      "ICitator interface definition",
      "Citator class with ImmutableDictionary<string, Template>",
      "Streaming ListCitations() implementation",
      "Default singleton pattern with Lazy<T>",
      "Static convenience methods"
    ]
  },

  "criticalAnchors": [
    "IMMUTABLE: ICitator interface for DI abstraction (Gap Decision #3)",
    "IMMUTABLE: Citator.Templates is ImmutableDictionary (Gap Decision #2: thread-safe)",
    "IMMUTABLE: ListCitations() returns IEnumerable<Citation> (Gap Decision #6: streaming)",
    "IMMUTABLE: Default singleton uses Lazy<Citator> for thread-safety",
    "IMMUTABLE: Loads embedded YAML resources by default",
    "IMMUTABLE: Static convenience methods delegate to Default instance"
  ],

  "agentInstructions": "## Task 3.2: Implement Citator Class and ICitator Interface\n\n### Step 1: Create ICitator Interface\n\n**Create `src/CiteUrl.Core/Templates/ICitator.cs`:**\n\n```csharp\nusing System.Collections.Immutable;\nusing System.Text.RegularExpressions;\nusing CiteUrl.Core.Models;\n\nnamespace CiteUrl.Core.Templates;\n\npublic interface ICitator\n{\n    ImmutableDictionary<string, Template> Templates { get; }\n    Citation? Cite(string text, bool broad = true);\n    IEnumerable<Citation> ListCitations(string text, Regex? idBreaks = null);\n    string InsertLinks(string text, Dictionary<string, string>? attrs = null, bool addTitle = true, \n        bool urlOptional = false, bool redundantLinks = true, Regex? idBreaks = null, \n        bool ignoreMarkup = true, string markupFormat = \"html\");\n}\n```\n\n### Step 2: Create Citator Class\n\n**Create `src/CiteUrl.Core/Templates/Citator.cs`:**\n\n```csharp\nusing System.Collections.Immutable;\nusing System.Text.RegularExpressions;\nusing CiteUrl.Core.Models;\nusing CiteUrl.Core.Utilities;\nusing CiteUrl.Core.Exceptions;\nusing Serilog;\n\nnamespace CiteUrl.Core.Templates;\n\npublic class Citator : ICitator\n{\n    private static readonly ILogger? Logger = Log.Logger;\n    private static readonly Lazy<Citator> _default = new(() => CreateDefault(), true);\n\n    public static Citator Default => _default.Value;\n    public ImmutableDictionary<string, Template> Templates { get; init; }\n    public TimeSpan RegexTimeout { get; init; } = TimeSpan.FromSeconds(1);\n\n    public Citator(ImmutableDictionary<string, Template> templates, TimeSpan? regexTimeout = null)\n    {\n        Templates = templates;\n        RegexTimeout = regexTimeout ?? TimeSpan.FromSeconds(1);\n    }\n\n    private static Citator CreateDefault()\n    {\n        try\n        {\n            var yaml = ResourceLoader.LoadAllDefaultYaml();\n            var templates = YamlLoader.LoadYaml(yaml, \"default-templates\");\n            Logger?.Information(\"Loaded {TemplateCount} default templates\", templates.Count);\n            return new Citator(templates.ToImmutableDictionary());\n        }\n        catch (Exception ex)\n        {\n            Logger?.Error(ex, \"Failed to load default templates\");\n            throw new CiteUrlYamlException(\"Failed to initialize default Citator\", ex);\n        }\n    }\n\n    public static Citator FromYaml(string yaml, string? fileName = null)\n    {\n        var templates = YamlLoader.LoadYaml(yaml, fileName);\n        return new Citator(templates.ToImmutableDictionary());\n    }\n\n    public Citation? Cite(string text, bool broad = true)\n    {\n        return ListCitations(text).FirstOrDefault();\n    }\n\n    public IEnumerable<Citation> ListCitations(string text, Regex? idBreaks = null)\n    {\n        var citations = new List<Citation>();\n\n        // Find all longform citations from all templates\n        foreach (var template in Templates.Values)\n        {\n            var regexes = broad ? template.BroadRegexes.Concat(template.Regexes) : template.Regexes;\n            \n            foreach (var regex in regexes)\n            {\n                try\n                {\n                    foreach (Match match in regex.Matches(text))\n                    {\n                        var citation = Citation.FromMatch(match, template, text, null, RegexTimeout);\n                        citations.Add(citation);\n                    }\n                }\n                catch (RegexMatchTimeoutException ex)\n                {\n                    Logger?.Warning(\"Regex timeout for template {TemplateName}: {Pattern}\",\n                        template.Name, regex.ToString());\n                }\n            }\n        }\n\n        // Sort by position\n        citations = citations.OrderBy(c => c.Span.Start).ToList();\n\n        // Remove overlapping citations (prefer longer match)\n        citations = RemoveOverlaps(citations);\n\n        // Find shortforms and idforms for each citation\n        foreach (var citation in citations)\n        {\n            // Yield longform\n            yield return citation;\n\n            // Find idform chain\n            var current = citation;\n            while (true)\n            {\n                var nextCitationStart = citations\n                    .Where(c => c.Span.Start > current.Span.End)\n                    .Select(c => (int?)c.Span.Start)\n                    .FirstOrDefault();\n\n                var idform = current.GetIdformCitation(nextCitationStart);\n                if (idform == null)\n                    break;\n\n                yield return idform;\n                current = idform;\n\n                if (idBreaks != null && idBreaks.IsMatch(text.Substring(current.Span.End)))\n                    break;\n            }\n        }\n    }\n\n    private List<Citation> RemoveOverlaps(List<Citation> citations)\n    {\n        var result = new List<Citation>();\n        Citation? last = null;\n\n        foreach (var citation in citations)\n        {\n            if (last == null || citation.Span.Start >= last.Span.End)\n            {\n                result.Add(citation);\n                last = citation;\n            }\n            else if (citation.Text.Length > last.Text.Length)\n            {\n                result[result.Count - 1] = citation;\n                last = citation;\n            }\n        }\n\n        return result;\n    }\n\n    public string InsertLinks(string text, Dictionary<string, string>? attrs = null, \n        bool addTitle = true, bool urlOptional = false, bool redundantLinks = true, \n        Regex? idBreaks = null, bool ignoreMarkup = true, string markupFormat = \"html\")\n    {\n        // Implementation in Task 4.1\n        throw new NotImplementedException(\"InsertLinks will be implemented in Task 4.1\");\n    }\n\n    // Static convenience methods\n    public static Citation? Cite(string text, bool broad = true, ICitator? citator = null)\n    {\n        return (citator ?? Default).Cite(text, broad);\n    }\n\n    public static IEnumerable<Citation> ListCitations(string text, ICitator? citator = null, Regex? idBreaks = null)\n    {\n        return (citator ?? Default).ListCitations(text, idBreaks);\n    }\n}\n```\n\n### Step 3: Create Tests\n\n**Create `tests/CiteUrl.Core.Tests/Templates/CitatorTests.cs`:**\n\n```csharp\nusing CiteUrl.Core.Templates;\nusing Shouldly;\nusing Xunit;\n\npublic class CitatorTests\n{\n    [Fact]\n    public void Default_LoadsAllTemplates()\n    {\n        var citator = Citator.Default;\n        citator.Templates.Count.ShouldBeGreaterThan(50);\n    }\n\n    [Fact]\n    public void Cite_FindsFirstCitation()\n    {\n        var text = \"See 42 U.S.C. ยง 1983 for details.\";\n        var citation = Citator.Cite(text);\n        \n        citation.ShouldNotBeNull();\n        citation!.Text.ShouldContain(\"1983\");\n    }\n\n    [Fact]\n    public void ListCitations_ReturnsStreamingEnumerable()\n    {\n        var text = \"See 42 U.S.C. ยง 1983 and 29 C.F.R. ยง 1630.2.\";\n        var citations = Citator.ListCitations(text);\n        \n        citations.ShouldBeAssignableTo<IEnumerable<Models.Citation>>();\n        citations.Count().ShouldBeGreaterThanOrEqualTo(1);\n    }\n}\n```\n\n### Verification\n- [ ] ICitator interface defined\n- [ ] Citator uses ImmutableDictionary\n- [ ] Default singleton thread-safe (Lazy<T>)\n- [ ] ListCitations returns IEnumerable\n- [ ] Tests pass",

  "successCriteria": [
    "ICitator interface created with all public methods",
    "Citator class implements ICitator",
    "Citator.Templates is ImmutableDictionary<string, Template>",
    "Default singleton uses Lazy<Citator> (thread-safe)",
    "ListCitations() returns IEnumerable<Citation> (streaming)",
    "Overlapping citation removal works",
    "Idform chain resolution works",
    "All 5+ Citator tests pass"
  ],

  "executionControls": {
    "scopeAndBoundaries": {
      "mustImplement": [
        "ICitator interface for DI",
        "ImmutableDictionary for templates",
        "Streaming IEnumerable return type",
        "Thread-safe Lazy singleton",
        "Overlap removal algorithm",
        "Idform chain resolution"
      ]
    }
  },

  "associatedArtifacts": [
    {
      "type": "source_file",
      "path": "src/CiteUrl.Core/Templates/ICitator.cs",
      "description": "Interface for DI abstraction"
    },
    {
      "type": "source_file",
      "path": "src/CiteUrl.Core/Templates/Citator.cs",
      "description": "Main orchestrator class"
    },
    {
      "type": "test_file",
      "path": "tests/CiteUrl.Core.Tests/Templates/CitatorTests.cs",
      "description": "Citator tests"
    }
  ]
}
