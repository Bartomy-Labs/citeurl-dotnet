{
  "id": "3.1",
  "title": "Implement Citation Record",
  "objective": "Create immutable Citation record with parent/child relationships, token extraction from regex matches, and lazy-compiled shortform/idform regexes",
  "complexity": "complex",
  "phaseId": "3",
  "taskNumber": 1,
  "totalTasksInPhase": 3,

  "metadata": {
    "taskType": "implementation",
    "estimatedDuration": "6-8 hours",
    "dependencies": ["2.1", "2.2", "2.3"],
    "requiredContext": [
      "Phase 2 completion summary",
      "Template class from Phase 2",
      "Gap Decision #6: Streaming enumeration (IEnumerable)"
    ],
    "skillLevel": "advanced"
  },

  "contextManagement": {
    "isFirstInPhase": true,
    "isLastInPhase": false,
    "requiredContext": [
      "Phase 2 boundary summary (template system complete)",
      "Template class with compiled regexes",
      "TokenType normalization",
      "StringBuilder for URL/name building"
    ],
    "contextToPreserve": [
      "Citation record class",
      "Parent-child citation relationships",
      "Token extraction from regex Match objects",
      "Lazy shortform/idform regex compilation",
      "URL and Name computed properties"
    ]
  },

  "criticalAnchors": [
    "IMMUTABLE: Citation is a record class (immutable)",
    "IMMUTABLE: Parent-child linkage for shortforms and idforms",
    "IMMUTABLE: Lazy regex compilation for shortform/idform patterns (per-citation instance)",
    "IMMUTABLE: Token inheritance from parent citations",
    "IMMUTABLE: URL and Name are computed properties (use StringBuilder)",
    "IMMUTABLE: Thread-safe design (no mutable state)"
  ],

  "agentInstructions": "## Task 3.1: Implement Citation Record\n\n### Overview\nYou will create the Citation record that represents a found citation with all its metadata, tokens, and relationships.\n\n### Step-by-Step Instructions\n\n#### STEP 1: Create Citation Record\n\n**Create `src/CiteUrl.Core/Models/Citation.cs`:**\n\n```csharp\nusing System.Collections.Immutable;\nusing System.Text.RegularExpressions;\nusing CiteUrl.Core.Templates;\nusing CiteUrl.Core.Tokens;\n\nnamespace CiteUrl.Core.Models;\n\n/// <summary>\n/// Represents a legal citation found in text.\n/// Immutable record for thread safety.\n/// </summary>\npublic record class Citation\n{\n    /// <summary>\n    /// The matched citation text.\n    /// </summary>\n    public string Text { get; init; } = string.Empty;\n\n    /// <summary>\n    /// Position of the citation in the source text (start index, end index).\n    /// </summary>\n    public (int Start, int End) Span { get; init; }\n\n    /// <summary>\n    /// The full source text that was searched.\n    /// </summary>\n    public string SourceText { get; init; } = string.Empty;\n\n    /// <summary>\n    /// The template that matched this citation.\n    /// </summary>\n    public Template Template { get; init; } = null!;\n\n    /// <summary>\n    /// Parent citation (for shortforms and idforms).\n    /// Null for longform citations.\n    /// </summary>\n    public Citation? Parent { get; init; }\n\n    /// <summary>\n    /// Normalized token values extracted from the match.\n    /// </summary>\n    public ImmutableDictionary<string, string> Tokens { get; init; } = \n        ImmutableDictionary<string, string>.Empty;\n\n    /// <summary>\n    /// Raw token values as captured by regex (before normalization).\n    /// </summary>\n    public ImmutableDictionary<string, string> RawTokens { get; init; } = \n        ImmutableDictionary<string, string>.Empty;\n\n    /// <summary>\n    /// Lazy-initialized shortform regexes compiled with parent token values.\n    /// </summary>\n    private Lazy<ImmutableList<Regex>>? _shortformRegexes;\n\n    /// <summary>\n    /// Lazy-initialized idform regexes compiled with parent token values.\n    /// </summary>\n    private Lazy<ImmutableList<Regex>>? _idformRegexes;\n\n    /// <summary>\n    /// Regex timeout for shortform/idform pattern matching.\n    /// </summary>\n    public TimeSpan RegexTimeout { get; init; } = TimeSpan.FromSeconds(1);\n\n    /// <summary>\n    /// The constructed URL for this citation (computed property).\n    /// </summary>\n    public string? Url => Template.UrlBuilder?.Build(Tokens.ToDictionary(kv => kv.Key, kv => kv.Value), RegexTimeout);\n\n    /// <summary>\n    /// The display name for this citation (computed property).\n    /// </summary>\n    public string? Name => Template.NameBuilder?.Build(Tokens.ToDictionary(kv => kv.Key, kv => kv.Value), RegexTimeout);\n\n    /// <summary>\n    /// Gets shortform regexes with parent token values substituted.\n    /// </summary>\n    public ImmutableList<Regex> ShortformRegexes\n    {\n        get\n        {\n            _shortformRegexes ??= new Lazy<ImmutableList<Regex>>(() => CompileShortformRegexes());\n            return _shortformRegexes.Value;\n        }\n    }\n\n    /// <summary>\n    /// Gets idform regexes with parent token values substituted.\n    /// </summary>\n    public ImmutableList<Regex> IdformRegexes\n    {\n        get\n        {\n            _idformRegexes ??= new Lazy<ImmutableList<Regex>>(() => CompileIdformRegexes());\n            return _idformRegexes.Value;\n        }\n    }\n\n    /// <summary>\n    /// Constructor from regex match.\n    /// </summary>\n    public static Citation FromMatch(\n        Match match,\n        Template template,\n        string sourceText,\n        Citation? parent = null,\n        TimeSpan? regexTimeout = null)\n    {\n        // Extract raw tokens from match groups\n        var rawTokens = ImmutableDictionary.CreateBuilder<string, string>();\n        var tokens = ImmutableDictionary.CreateBuilder<string, string>();\n\n        foreach (var (tokenName, tokenType) in template.Tokens)\n        {\n            var group = match.Groups[tokenName];\n            if (group.Success)\n            {\n                rawTokens[tokenName] = group.Value;\n                \n                // Normalize token\n                var normalized = tokenType.Normalize(group.Value, regexTimeout);\n                if (normalized != null)\n                {\n                    tokens[tokenName] = normalized;\n                }\n            }\n        }\n\n        // Inherit tokens from parent\n        if (parent != null)\n        {\n            foreach (var (tokenName, value) in parent.Tokens)\n            {\n                // Stop inheriting after first token we captured\n                if (rawTokens.ContainsKey(tokenName))\n                    break;\n                \n                // Inherit both raw and normalized\n                if (!rawTokens.ContainsKey(tokenName))\n                {\n                    rawTokens[tokenName] = parent.RawTokens.GetValueOrDefault(tokenName, value);\n                    tokens[tokenName] = value;\n                }\n            }\n        }\n\n        return new Citation\n        {\n            Text = match.Value,\n            Span = (match.Index, match.Index + match.Length),\n            SourceText = sourceText,\n            Template = template,\n            Parent = parent,\n            RawTokens = rawTokens.ToImmutable(),\n            Tokens = tokens.ToImmutable(),\n            RegexTimeout = regexTimeout ?? TimeSpan.FromSeconds(1)\n        };\n    }\n\n    /// <summary>\n    /// Compiles shortform regexes with {same token} replaced by parent values.\n    /// </summary>\n    private ImmutableList<Regex> CompileShortformRegexes()\n    {\n        var regexes = ImmutableList.CreateBuilder<Regex>();\n\n        foreach (var pattern in Template.ProcessedShortformPatterns)\n        {\n            try\n            {\n                var processedPattern = SubstituteSameTokens(pattern);\n                regexes.Add(new Regex(processedPattern, RegexOptions.Compiled, RegexTimeout));\n            }\n            catch (RegexMatchTimeoutException)\n            {\n                // Skip patterns that timeout during compilation\n                continue;\n            }\n        }\n\n        return regexes.ToImmutable();\n    }\n\n    /// <summary>\n    /// Compiles idform regexes with {same token} replaced by parent values.\n    /// Also adds basic \"Id.\" pattern.\n    /// </summary>\n    private ImmutableList<Regex> CompileIdformRegexes()\n    {\n        var regexes = ImmutableList.CreateBuilder<Regex>();\n\n        // Add basic id pattern\n        regexes.Add(new Regex(@\"(?<!\\w)[Ii]d\\.(?!\\w)\", RegexOptions.Compiled, RegexTimeout));\n\n        foreach (var pattern in Template.ProcessedIdformPatterns)\n        {\n            try\n            {\n                var processedPattern = SubstituteSameTokens(pattern);\n                regexes.Add(new Regex(processedPattern, RegexOptions.Compiled, RegexTimeout));\n            }\n            catch (RegexMatchTimeoutException)\n            {\n                continue;\n            }\n        }\n\n        return regexes.ToImmutable();\n    }\n\n    /// <summary>\n    /// Replaces {same token_name} with the raw token value from this citation.\n    /// </summary>\n    private string SubstituteSameTokens(string pattern)\n    {\n        var result = pattern;\n        var regex = new Regex(@\"\\{same ([^}]+)\\}\");\n        \n        result = regex.Replace(result, match =>\n        {\n            var tokenName = match.Groups[1].Value;\n            \n            if (RawTokens.TryGetValue(tokenName, out var value))\n            {\n                // Escape the value for use in regex\n                return Regex.Escape(value);\n            }\n            \n            // If token not found, leave as-is (will likely fail to match)\n            return match.Value;\n        });\n\n        return result;\n    }\n\n    /// <summary>\n    /// Finds shortform citations that reference this citation.\n    /// </summary>\n    /// <param name=\"afterIndex\">Start searching after this index in source text.</param>\n    /// <param name=\"untilIndex\">Stop searching at this index.</param>\n    /// <returns>Enumerable of shortform citations.</returns>\n    public IEnumerable<Citation> GetShortformCitations(int? afterIndex = null, int? untilIndex = null)\n    {\n        var startIndex = afterIndex ?? Span.End;\n        var endIndex = untilIndex ?? SourceText.Length;\n        \n        var searchText = SourceText.Substring(startIndex, endIndex - startIndex);\n\n        foreach (var regex in ShortformRegexes)\n        {\n            foreach (Match match in regex.Matches(searchText))\n            {\n                // Adjust match index to source text position\n                var adjustedMatch = AdjustMatch(match, startIndex);\n                yield return FromMatch(adjustedMatch, Template, SourceText, parent: this, RegexTimeout);\n            }\n        }\n    }\n\n    /// <summary>\n    /// Finds the next idform citation (\"Id.\") that references this citation.\n    /// </summary>\n    public Citation? GetIdformCitation(int? untilIndex = null)\n    {\n        var startIndex = Span.End;\n        var endIndex = untilIndex ?? SourceText.Length;\n        \n        var searchText = SourceText.Substring(startIndex, endIndex - startIndex);\n\n        foreach (var regex in IdformRegexes)\n        {\n            var match = regex.Match(searchText);\n            if (match.Success)\n            {\n                var adjustedMatch = AdjustMatch(match, startIndex);\n                return FromMatch(adjustedMatch, Template, SourceText, parent: this, RegexTimeout);\n            }\n        }\n\n        return null;\n    }\n\n    /// <summary>\n    /// Adjusts a match's index to account for substring offset.\n    /// </summary>\n    private Match AdjustMatch(Match match, int offset)\n    {\n        // Create a new match with adjusted index by re-matching at the correct position\n        var pattern = match.Value;\n        var fullMatch = Regex.Match(SourceText.Substring(offset), Regex.Escape(pattern));\n        return fullMatch;\n    }\n}\n```\n\n#### STEP 2: Create Unit Tests\n\n**Create `tests/CiteUrl.Core.Tests/Models/CitationTests.cs`:**\n\n```csharp\nusing System.Collections.Immutable;\nusing System.Text.RegularExpressions;\nusing CiteUrl.Core.Models;\nusing CiteUrl.Core.Templates;\nusing CiteUrl.Core.Tokens;\nusing Shouldly;\nusing Xunit;\n\nnamespace CiteUrl.Core.Tests.Models;\n\npublic class CitationTests\n{\n    private Template CreateTestTemplate()\n    {\n        var tokens = ImmutableDictionary<string, TokenType>.Empty\n            .Add(\"title\", new TokenType { Regex = @\"\\d+\" })\n            .Add(\"section\", new TokenType { Regex = @\"\\d+\\w*\" });\n\n        return new Template(\n            name: \"Test Template\",\n            tokens: tokens,\n            metadata: ImmutableDictionary<string, string>.Empty,\n            patterns: new[] { @\"{title} U\\.S\\.C\\. § {section}\" },\n            broadPatterns: Array.Empty<string>(),\n            shortformPatterns: new[] { @\"§ {same section}\" },\n            idformPatterns: new[] { @\"[Ii]d\\.\" },\n            urlBuilder: null,\n            nameBuilder: null\n        );\n    }\n\n    [Fact]\n    public void FromMatch_ExtractsTokensFromMatch()\n    {\n        // Arrange\n        var template = CreateTestTemplate();\n        var text = \"See 42 U.S.C. § 1983 for details.\";\n        var match = template.Regexes[0].Match(text);\n\n        // Act\n        var citation = Citation.FromMatch(match, template, text);\n\n        // Assert\n        citation.Text.ShouldBe(\"42 U.S.C. § 1983\");\n        citation.Tokens[\"title\"].ShouldBe(\"42\");\n        citation.Tokens[\"section\"].ShouldBe(\"1983\");\n        citation.Span.Start.ShouldBe(4);\n    }\n\n    [Fact]\n    public void FromMatch_InheritsTokensFromParent()\n    {\n        // Arrange\n        var template = CreateTestTemplate();\n        var parentText = \"42 U.S.C. § 1983\";\n        var parentMatch = template.Regexes[0].Match(parentText);\n        var parent = Citation.FromMatch(parentMatch, template, parentText);\n\n        var childText = \"§ 1985\";\n        var childMatch = template.ShortformRegexes[0].Match(childText); // Would need actual shortform regex\n        \n        // Simulate shortform match\n        var childCitation = new Citation\n        {\n            Template = template,\n            Parent = parent,\n            RawTokens = ImmutableDictionary<string, string>.Empty.Add(\"section\", \"1985\"),\n            Tokens = parent.Tokens.SetItem(\"section\", \"1985\") // Inherit title, override section\n        };\n\n        // Assert\n        childCitation.Tokens[\"title\"].ShouldBe(\"42\"); // Inherited\n        childCitation.Tokens[\"section\"].ShouldBe(\"1985\"); // Overridden\n    }\n\n    [Fact]\n    public void ShortformRegexes_CompilesLazily()\n    {\n        // Arrange\n        var template = CreateTestTemplate();\n        var text = \"42 U.S.C. § 1983\";\n        var match = template.Regexes[0].Match(text);\n        var citation = Citation.FromMatch(match, template, text);\n\n        // Act\n        var shortformRegexes = citation.ShortformRegexes;\n\n        // Assert\n        shortformRegexes.ShouldNotBeEmpty();\n        // Accessing again should return same instance (lazy)\n        citation.ShortformRegexes.ShouldBe(shortformRegexes);\n    }\n\n    [Fact]\n    public void IdformRegexes_IncludesBasicIdPattern()\n    {\n        // Arrange\n        var template = CreateTestTemplate();\n        var text = \"42 U.S.C. § 1983\";\n        var match = template.Regexes[0].Match(text);\n        var citation = Citation.FromMatch(match, template, text);\n\n        // Act\n        var idformRegexes = citation.IdformRegexes;\n\n        // Assert\n        idformRegexes.ShouldNotBeEmpty();\n        idformRegexes.ShouldContain(r => r.IsMatch(\"Id.\"));\n        idformRegexes.ShouldContain(r => r.IsMatch(\"id.\"));\n    }\n\n    [Fact]\n    public void Url_ComputedFromUrlBuilder()\n    {\n        // Arrange\n        var urlBuilder = new CiteUrl.Core.Tokens.StringBuilder\n        {\n            Parts = new[] { \"https://example.com/{title}/{section}\" },\n            UrlEncode = false\n        };\n\n        var tokens = ImmutableDictionary<string, TokenType>.Empty\n            .Add(\"title\", new TokenType { Regex = @\"\\d+\" })\n            .Add(\"section\", new TokenType { Regex = @\"\\d+\" });\n\n        var template = new Template(\n            name: \"Test\",\n            tokens: tokens,\n            metadata: ImmutableDictionary<string, string>.Empty,\n            patterns: new[] { @\"{title} USC {section}\" },\n            broadPatterns: Array.Empty<string>(),\n            shortformPatterns: Array.Empty<string>(),\n            idformPatterns: Array.Empty<string>(),\n            urlBuilder: urlBuilder,\n            nameBuilder: null\n        );\n\n        var citation = new Citation\n        {\n            Template = template,\n            Tokens = ImmutableDictionary<string, string>.Empty\n                .Add(\"title\", \"42\")\n                .Add(\"section\", \"1983\")\n        };\n\n        // Act & Assert\n        citation.Url.ShouldBe(\"https://example.com/42/1983\");\n    }\n}\n```\n\n#### STEP 3: Build and Run Tests\n\n```bash\ndotnet build\ndotnet test --verbosity normal\n```\n\n### Verification Checklist\n- [ ] Citation records are immutable\n- [ ] Token extraction works from regex Match\n- [ ] Token inheritance from parent works\n- [ ] Shortform regex compilation is lazy\n- [ ] Idform regexes include basic \"Id.\" pattern\n- [ ] URL and Name computed properties work\n- [ ] All 5+ Citation tests pass\n\n### Post-Task Actions\nNone - proceed to Task 3.2",

  "successCriteria": [
    "Citation record class created as immutable record",
    "Citation.FromMatch() extracts tokens from regex matches",
    "Parent-child token inheritance works correctly",
    "Shortform/idform regexes compile lazily per citation",
    "{same token} replacement works in shortform patterns",
    "Url and Name are computed properties using StringBuilder",
    "All 5+ Citation tests pass",
    "Thread-safe design verified (no mutable state)"
  ],

  "pauseAndAskScenarios": [
    "If token inheritance logic is unclear",
    "If lazy regex compilation pattern needs clarification"
  ],

  "executionControls": {
    "scopeAndBoundaries": {
      "mustImplement": [
        "Immutable record class for Citation",
        "Token extraction from Match objects",
        "Parent-child relationships",
        "Lazy shortform/idform regex compilation",
        "Token inheritance from parent",
        "Computed Url and Name properties"
      ],
      "mustNotImplement": [
        "Do not compile shortform/idform at template level",
        "Do not use mutable state",
        "Do not skip token normalization"
      ],
      "flexible": [
        "Internal helper method names",
        "Match adjustment implementation details",
        "Test organization"
      ]
    },
    "riskFactors": [
      {
        "risk": "Lazy regex compilation could cause delays on first access",
        "mitigation": "Document lazy behavior, acceptable for per-citation patterns",
        "severity": "low"
      },
      {
        "risk": "Token inheritance logic could be complex",
        "mitigation": "Test thoroughly with nested citations",
        "severity": "medium"
      }
    ],
    "qualityGates": [
      "All tests must pass",
      "Citation must be immutable (record class)",
      "No mutable collections or state"
    ]
  },

  "associatedArtifacts": [
    {
      "type": "source_file",
      "path": "src/CiteUrl.Core/Models/Citation.cs",
      "description": "Immutable Citation record with parent/child relationships"
    },
    {
      "type": "test_file",
      "path": "tests/CiteUrl.Core.Tests/Models/CitationTests.cs",
      "description": "Unit tests for Citation functionality"
    }
  ]
}
