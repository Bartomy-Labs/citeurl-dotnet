{
  "id": "1.3",
  "title": "Implement StringBuilder (URL and Name Builder)",
  "objective": "Build string construction system that creates URLs and citation names from token dictionaries using template parts and pre-processing edits",
  "complexity": "moderate",
  "phaseId": "1",
  "taskNumber": 3,
  "totalTasksInPhase": 3,

  "metadata": {
    "taskType": "implementation",
    "estimatedDuration": "3-4 hours",
    "dependencies": ["1.2"],
    "requiredContext": [
      "TokenOperation from Task 1.2",
      "Token transformation pipeline understanding"
    ],
    "skillLevel": "intermediate"
  },

  "contextManagement": {
    "isFirstInPhase": false,
    "isLastInPhase": true,
    "requiredContext": [
      "TokenOperation.Apply() method from Task 1.2",
      "Understanding of token normalization pipeline"
    ],
    "contextToPreserve": [
      "StringBuilder class implementation",
      "Parts-based string concatenation logic",
      "Edit pipeline execution before building",
      "URL encoding for web URLs"
    ],
    "phaseBoundaryInstructions": "**PHASE 1 COMPLETE** - After this task, create comprehensive Phase 1 summary document (ingestion_phaseBoundary_phase1_[timestamp].md) with:\n- All classes implemented (TokenType, TokenOperation, StringBuilder)\n- Test coverage metrics\n- Any deviations from plan\n- Readiness checklist for Phase 2\n\n**MANDATORY: STOP after Phase 1 and wait for user approval before proceeding to Phase 2.**"
  },

  "criticalAnchors": [
    "IMMUTABLE: StringBuilder is a class (not record) - manages string construction state",
    "IMMUTABLE: Parts-based concatenation - skip parts with missing tokens",
    "IMMUTABLE: Edits executed BEFORE string building",
    "IMMUTABLE: Default values from template metadata",
    "IMMUTABLE: URL encoding applied for URL builders (space → %20, etc.)",
    "IMMUTABLE: Return null if all parts skipped (no valid URL/name possible)"
  ],

  "agentInstructions": "## Task 1.3: Implement StringBuilder (URL and Name Builder)\n\n### Overview\nYou will implement the StringBuilder class that constructs URLs and citation names by applying token edits and concatenating template parts.\n\n### Step-by-Step Instructions\n\n#### STEP 1: Create StringBuilder Class\n\n**Create `src/CiteUrl.Core/Tokens/StringBuilder.cs`:**\n\n```csharp\nusing System.Text;\nusing System.Web;\n\nnamespace CiteUrl.Core.Tokens;\n\n/// <summary>\n/// Builds strings (URLs, citation names) from token dictionaries using template parts.\n/// </summary>\npublic class StringBuilder\n{\n    /// <summary>\n    /// Ordered list of string parts with {token} placeholders.\n    /// Parts are concatenated if all referenced tokens are available.\n    /// </summary>\n    public IReadOnlyList<string> Parts { get; init; } = Array.Empty<string>();\n\n    /// <summary>\n    /// Operations to apply to tokens before building the string.\n    /// Can create derived tokens via Output property.\n    /// </summary>\n    public IReadOnlyList<TokenOperation> Edits { get; init; } = Array.Empty<TokenOperation>();\n\n    /// <summary>\n    /// Default token values from template metadata.\n    /// Merged with provided tokens (provided values take precedence).\n    /// </summary>\n    public IReadOnlyDictionary<string, string> Defaults { get; init; } = \n        new Dictionary<string, string>();\n\n    /// <summary>\n    /// If true, applies URL encoding to the final result.\n    /// </summary>\n    public bool UrlEncode { get; init; } = true;\n\n    /// <summary>\n    /// Builds a string by applying edits and concatenating parts with token values.\n    /// </summary>\n    /// <param name=\"tokens\">Token dictionary with values to substitute.</param>\n    /// <param name=\"regexTimeout\">Optional regex timeout for edit operations.</param>\n    /// <returns>The constructed string, or null if all parts were skipped.</returns>\n    public string? Build(Dictionary<string, string> tokens, TimeSpan? regexTimeout = null)\n    {\n        // Step 1: Merge defaults with provided tokens\n        var mergedTokens = new Dictionary<string, string>(Defaults);\n        foreach (var (key, value) in tokens)\n        {\n            mergedTokens[key] = value;\n        }\n\n        // Step 2: Execute edits (may modify tokens or create new ones)\n        foreach (var edit in Edits)\n        {\n            if (edit.Token != null && mergedTokens.ContainsKey(edit.Token))\n            {\n                var transformedValue = edit.Apply(mergedTokens[edit.Token], regexTimeout);\n                \n                // Store in output token if specified, otherwise update original\n                var targetToken = edit.Output ?? edit.Token;\n                mergedTokens[targetToken] = transformedValue;\n            }\n        }\n\n        // Step 3: Build string parts\n        var builtParts = new List<string>();\n        foreach (var part in Parts)\n        {\n            try\n            {\n                var builtPart = SubstituteTokens(part, mergedTokens);\n                builtParts.Add(builtPart);\n            }\n            catch (KeyNotFoundException)\n            {\n                // Part references missing token - skip this part\n                continue;\n            }\n        }\n\n        // Step 4: Concatenate and encode\n        if (builtParts.Count == 0)\n            return null;\n\n        var result = string.Concat(builtParts);\n        \n        if (UrlEncode)\n        {\n            // Simple URL encoding for common characters\n            result = result.Replace(\" \", \"%20\")\n                          .Replace(\"(\", \"%28\")\n                          .Replace(\")\", \"%29\");\n        }\n\n        return result;\n    }\n\n    /// <summary>\n    /// Substitutes {token} placeholders in a string with values from the dictionary.\n    /// </summary>\n    /// <param name=\"template\">String with {token} placeholders.</param>\n    /// <param name=\"tokens\">Token dictionary.</param>\n    /// <returns>String with placeholders replaced.</returns>\n    /// <exception cref=\"KeyNotFoundException\">Thrown if a referenced token is not in the dictionary.</exception>\n    private string SubstituteTokens(string template, Dictionary<string, string> tokens)\n    {\n        var result = new System.Text.StringBuilder(template);\n        \n        // Find and replace all {token} patterns\n        var regex = new System.Text.RegularExpressions.Regex(@\"\\{([^}]+)\\}\");\n        var matches = regex.Matches(template);\n        \n        // Process matches in reverse order to maintain string positions\n        for (int i = matches.Count - 1; i >= 0; i--)\n        {\n            var match = matches[i];\n            var tokenName = match.Groups[1].Value;\n            \n            if (!tokens.ContainsKey(tokenName))\n            {\n                throw new KeyNotFoundException($\"Token '{tokenName}' not found\");\n            }\n            \n            result.Remove(match.Index, match.Length);\n            result.Insert(match.Index, tokens[tokenName]);\n        }\n        \n        return result.ToString();\n    }\n}\n```\n\n#### STEP 2: Create Unit Tests\n\n**Create `tests/CiteUrl.Core.Tests/Tokens/StringBuilderTests.cs`:**\n\n```csharp\nusing CiteUrl.Core.Tokens;\nusing Shouldly;\nusing Xunit;\n\nnamespace CiteUrl.Core.Tests.Tokens;\n\npublic class StringBuilderTests\n{\n    [Fact]\n    public void Build_ConcatenatesAllPartsWithTokens()\n    {\n        // Arrange\n        var builder = new CiteUrl.Core.Tokens.StringBuilder\n        {\n            Parts = new[]\n            {\n                \"https://example.com/\",\n                \"{section}/\",\n                \"{subsection}\"\n            },\n            UrlEncode = false\n        };\n\n        var tokens = new Dictionary<string, string>\n        {\n            [\"section\"] = \"42\",\n            [\"subsection\"] = \"1983\"\n        };\n\n        // Act\n        var result = builder.Build(tokens);\n\n        // Assert\n        result.ShouldBe(\"https://example.com/42/1983\");\n    }\n\n    [Fact]\n    public void Build_SkipsPartsWithMissingTokens()\n    {\n        // Arrange\n        var builder = new CiteUrl.Core.Tokens.StringBuilder\n        {\n            Parts = new[]\n            {\n                \"https://example.com/\",\n                \"{section}\",\n                \"/{subsection}\"  // subsection is missing\n            },\n            UrlEncode = false\n        };\n\n        var tokens = new Dictionary<string, string>\n        {\n            [\"section\"] = \"42\"\n            // subsection missing\n        };\n\n        // Act\n        var result = builder.Build(tokens);\n\n        // Assert\n        result.ShouldBe(\"https://example.com/42\");\n    }\n\n    [Fact]\n    public void Build_ReturnsNullWhenAllPartsSkipped()\n    {\n        // Arrange\n        var builder = new CiteUrl.Core.Tokens.StringBuilder\n        {\n            Parts = new[]\n            {\n                \"{missing_token}\"\n            }\n        };\n\n        var tokens = new Dictionary<string, string>();\n\n        // Act\n        var result = builder.Build(tokens);\n\n        // Assert\n        result.ShouldBeNull();\n    }\n\n    [Fact]\n    public void Build_AppliesEditsBeforeBuilding()\n    {\n        // Arrange\n        var builder = new CiteUrl.Core.Tokens.StringBuilder\n        {\n            Parts = new[] { \"https://example.com/{section}\" },\n            Edits = new[]\n            {\n                new TokenOperation\n                {\n                    Action = TokenOperationAction.Sub,\n                    Data = (@\"[()]\", \"\"),\n                    Token = \"section\"\n                }\n            },\n            UrlEncode = false\n        };\n\n        var tokens = new Dictionary<string, string>\n        {\n            [\"section\"] = \"1983(b)\"\n        };\n\n        // Act\n        var result = builder.Build(tokens);\n\n        // Assert\n        result.ShouldBe(\"https://example.com/1983b\");\n    }\n\n    [Fact]\n    public void Build_SupportsOutputTokens()\n    {\n        // Arrange\n        var builder = new CiteUrl.Core.Tokens.StringBuilder\n        {\n            Parts = new[] { \"{base_url}/{normalized}\" },\n            Edits = new[]\n            {\n                new TokenOperation\n                {\n                    Action = TokenOperationAction.Case,\n                    Data = \"lower\",\n                    Token = \"section\",\n                    Output = \"normalized\"\n                }\n            },\n            Defaults = new Dictionary<string, string>\n            {\n                [\"base_url\"] = \"https://example.com\"\n            },\n            UrlEncode = false\n        };\n\n        var tokens = new Dictionary<string, string>\n        {\n            [\"section\"] = \"HELLO\"\n        };\n\n        // Act\n        var result = builder.Build(tokens);\n\n        // Assert\n        result.ShouldBe(\"https://example.com/hello\");\n    }\n\n    [Fact]\n    public void Build_MergesDefaultsWithProvidedTokens()\n    {\n        // Arrange\n        var builder = new CiteUrl.Core.Tokens.StringBuilder\n        {\n            Parts = new[] { \"{base}/{path}\" },\n            Defaults = new Dictionary<string, string>\n            {\n                [\"base\"] = \"default-base\",\n                [\"path\"] = \"default-path\"\n            },\n            UrlEncode = false\n        };\n\n        var tokens = new Dictionary<string, string>\n        {\n            [\"path\"] = \"custom-path\"\n            // base will use default\n        };\n\n        // Act\n        var result = builder.Build(tokens);\n\n        // Assert\n        result.ShouldBe(\"default-base/custom-path\");\n    }\n\n    [Fact]\n    public void Build_AppliesUrlEncoding()\n    {\n        // Arrange\n        var builder = new CiteUrl.Core.Tokens.StringBuilder\n        {\n            Parts = new[] { \"https://example.com/{section}\" },\n            UrlEncode = true\n        };\n\n        var tokens = new Dictionary<string, string>\n        {\n            [\"section\"] = \"test (with parens)\"\n        };\n\n        // Act\n        var result = builder.Build(tokens);\n\n        // Assert\n        result.ShouldBe(\"https://example.com/test%20%28with%20parens%29\");\n    }\n\n    [Fact]\n    public void Build_SkipsUrlEncodingWhenDisabled()\n    {\n        // Arrange\n        var builder = new CiteUrl.Core.Tokens.StringBuilder\n        {\n            Parts = new[] { \"{title} U.S.C. § {section}\" },\n            UrlEncode = false\n        };\n\n        var tokens = new Dictionary<string, string>\n        {\n            [\"title\"] = \"42\",\n            [\"section\"] = \"1983\"\n        };\n\n        // Act\n        var result = builder.Build(tokens);\n\n        // Assert\n        result.ShouldBe(\"42 U.S.C. § 1983\");\n    }\n}\n```\n\n#### STEP 3: Build and Run Tests\n\n```bash\ndotnet build\ndotnet test --verbosity normal\n```\n\nVerify all tests pass (should see ~25 total tests passing across all token classes).\n\n#### STEP 4: Create Phase 1 Boundary Summary\n\n**Create `.featurePlans/CiteUrl/ingestion_phaseBoundary_phase1_[timestamp].md`:**\n\n```markdown\n# Phase 1 Boundary Summary: Foundation & Token System\n**Phase**: 1 of 4  \n**Completed**: [Current Date]  \n**Status**: ✅ COMPLETE\n\n## Tasks Completed\n\n### Task 1.1: Project Setup and Solution Structure\n- ✅ .NET 9 solution created with 3 projects\n- ✅ Core library: CiteUrl.Core (YamlDotNet + Serilog dependencies)\n- ✅ DI Extensions: CiteUrl.Extensions.DependencyInjection\n- ✅ Test project: CiteUrl.Core.Tests (xUnit + Shouldly)\n- ✅ GitHub Actions workflows (ci.yml, release.yml)\n- ✅ Directory structure created\n- ✅ README.md and .editorconfig configured\n\n### Task 1.2: TokenType and TokenOperation\n- ✅ TokenOperation record with 5 action types implemented\n- ✅ Number style conversion (1-100) for roman/cardinal/ordinal/digit\n- ✅ Case-insensitive lookup tables\n- ✅ Mandatory vs. optional operation handling\n- ✅ TokenType normalization pipeline\n- ✅ 15+ unit tests passing\n\n### Task 1.3: StringBuilder\n- ✅ StringBuilder class for URL/name construction\n- ✅ Parts-based concatenation with token substitution\n- ✅ Edit pipeline execution before building\n- ✅ URL encoding support\n- ✅ Default value merging\n- ✅ 8+ unit tests passing\n\n## Test Coverage Metrics\n- **Total Tests**: 25+\n- **All Passing**: ✅ Yes\n- **Coverage**: >90% for token classes\n- **No Warnings**: ✅ Confirmed\n\n## Classes Implemented\n1. `TokenOperation` (record) - Token transformation operations\n2. `TokenType` (record) - Token definitions with normalization\n3. `StringBuilder` (class) - String construction from tokens\n\n## Deviations from Plan\nNone - all implementations match original specification.\n\n## Readiness for Phase 2\n\n**Ready**: ✅ YES\n\n**Prerequisites Met**:\n- [x] Token system fully functional\n- [x] Test coverage >80%\n- [x] All builds successful\n- [x] No compiler warnings\n\n**Phase 2 Dependencies**:\n- Token system (available)\n- StringBuilder for URL/name building (available)\n- YAML deserialization understanding (next phase)\n\n## Next Phase Preview\n\n**Phase 2: Template System & Regex Compilation**\n- Task 2.1: Implement Template class with regex compilation\n- Task 2.2: YAML template deserialization with YamlDotNet\n- Task 2.3: Embed default YAML templates as resources\n\nEstimated Duration: 1.5 weeks\n\n---\n\n**⚠️ MANDATORY STOP - Awaiting user approval to proceed to Phase 2**\n```\n\n### Verification Checklist\n- [ ] StringBuilder.Build() concatenates parts correctly\n- [ ] Missing optional tokens skip parts gracefully\n- [ ] Edits execute before building\n- [ ] URL encoding applied when enabled\n- [ ] Metadata defaults work\n- [ ] All 25+ tests pass\n- [ ] Phase 1 boundary summary created\n- [ ] Ready for user approval before Phase 2\n\n### Post-Task Actions\n**STOP HERE** - Do not proceed to Phase 2 without explicit user approval.",

  "successCriteria": [
    "StringBuilder class created with parts-based concatenation",
    "Token substitution works with {token} placeholder syntax",
    "Missing optional tokens cause parts to be skipped (not errors)",
    "Edit operations execute before string building",
    "URL encoding applies to final output when enabled",
    "Default values merge correctly with provided tokens",
    "All 8+ StringBuilder tests pass",
    "Total test count across Phase 1 is 25+ tests passing",
    "Phase 1 boundary summary document created",
    "No compilation warnings in solution"
  ],

  "pauseAndAskScenarios": [
    "If URL encoding requirements differ from simple space/%20 conversion",
    "If phase boundary summary needs additional sections"
  ],

  "executionControls": {
    "scopeAndBoundaries": {
      "mustImplement": [
        "Parts-based string concatenation",
        "Token substitution with {token} syntax",
        "Edit pipeline execution before building",
        "URL encoding for URLs",
        "Default value merging",
        "Phase 1 boundary summary document"
      ],
      "mustNotImplement": [
        "Do not proceed to Phase 2 without user approval",
        "Do not add complex URL encoding beyond space/parens",
        "Do not make StringBuilder a record type (should be class)"
      ],
      "flexible": [
        "Internal helper method structure",
        "Exact regex pattern for token substitution",
        "Phase summary document formatting"
      ]
    },
    "phaseBoundaryProtocol": {
      "mandatory": true,
      "actions": [
        "Create ingestion_phaseBoundary_phase1_[timestamp].md",
        "Include all task summaries",
        "Report test coverage metrics",
        "List any deviations from plan",
        "Provide readiness checklist for Phase 2",
        "STOP and wait for user approval"
      ]
    },
    "riskFactors": [
      {
        "risk": "URL encoding might be insufficient for complex URLs",
        "mitigation": "Start with basic encoding (space, parens), expand if needed",
        "severity": "low"
      }
    ],
    "qualityGates": [
      "All tests must pass",
      "No compilation warnings",
      "Test coverage >80% overall",
      "Phase boundary document created"
    ]
  },

  "associatedArtifacts": [
    {
      "type": "source_file",
      "path": "src/CiteUrl.Core/Tokens/StringBuilder.cs",
      "description": "String builder class for URL and name construction"
    },
    {
      "type": "test_file",
      "path": "tests/CiteUrl.Core.Tests/Tokens/StringBuilderTests.cs",
      "description": "Unit tests for StringBuilder functionality"
    },
    {
      "type": "phase_boundary",
      "path": ".featurePlans/CiteUrl/ingestion_phaseBoundary_phase1_[timestamp].md",
      "description": "Comprehensive Phase 1 completion summary"
    }
  ]
}
