{
  "id": "1.2",
  "title": "Implement TokenType and TokenOperation",
  "objective": "Build token normalization system with regex substitution, lookup tables, case transforms, number style conversion, and left-padding operations",
  "complexity": "moderate",
  "phaseId": "1",
  "taskNumber": 2,
  "totalTasksInPhase": 3,

  "metadata": {
    "taskType": "implementation",
    "estimatedDuration": "4-6 hours",
    "dependencies": ["1.1"],
    "requiredContext": [
      "Solution structure from Task 1.1",
      "Token normalization requirements from plan"
    ],
    "skillLevel": "intermediate-advanced"
  },

  "contextManagement": {
    "isFirstInPhase": false,
    "isLastInPhase": false,
    "requiredContext": [
      "Project structure created in Task 1.1",
      "Tokens/ directory exists",
      "Test project configured"
    ],
    "contextToPreserve": [
      "TokenOperation record with 5 action types implemented",
      "TokenType record with normalization pipeline",
      "Unit tests for all token operations"
    ]
  },

  "criticalAnchors": [
    "IMMUTABLE: TokenType and TokenOperation are record types (immutable)",
    "IMMUTABLE: Functional transformations with no side effects",
    "IMMUTABLE: Mandatory flag controls exception vs. skip behavior",
    "IMMUTABLE: Support 6 operation types: Sub, Lookup, Case, LeftPad, NumberStyle, and passthrough",
    "IMMUTABLE: Number style conversion must support 1-100 (roman, cardinal, ordinal, digit)",
    "IMMUTABLE: Lookup tables are case-insensitive",
    "IMMUTABLE: Chain multiple edits in sequence (pipeline pattern)"
  ],

  "agentInstructions": "## Task 1.2: Implement TokenType and TokenOperation\n\n### Overview\nYou will implement the token normalization system that transforms raw regex-captured values into standardized forms. This is a critical foundation for citation parsing.\n\n### Step-by-Step Instructions\n\n#### STEP 1: Create TokenOperation Record\n\n**Create `src/CiteUrl.Core/Tokens/TokenOperation.cs`:**\n\n```csharp\nusing System.Text.RegularExpressions;\nusing System.Globalization;\n\nnamespace CiteUrl.Core.Tokens;\n\n/// <summary>\n/// Defines the type of transformation operation to apply to a token value.\n/// </summary>\npublic enum TokenOperationAction\n{\n    /// <summary>Regex substitution (search and replace)</summary>\n    Sub,\n    \n    /// <summary>Dictionary lookup (map key to value)</summary>\n    Lookup,\n    \n    /// <summary>Case transformation (upper/lower/title)</summary>\n    Case,\n    \n    /// <summary>Left-pad with character to specified length</summary>\n    LeftPad,\n    \n    /// <summary>Convert between number representations (roman/cardinal/ordinal/digit)</summary>\n    NumberStyle\n}\n\n/// <summary>\n/// Represents a single transformation operation applied to a token value.\n/// Immutable record for functional pipeline processing.\n/// </summary>\npublic record TokenOperation\n{\n    /// <summary>\n    /// The type of transformation to apply.\n    /// </summary>\n    public TokenOperationAction Action { get; init; }\n\n    /// <summary>\n    /// The data required for the transformation. Type depends on Action:\n    /// - Sub: (string pattern, string replacement) tuple\n    /// - Lookup: Dictionary&lt;string, string&gt;\n    /// - Case: string (\"upper\", \"lower\", \"title\")\n    /// - LeftPad: (char padChar, int totalWidth) tuple\n    /// - NumberStyle: (string from, string to) tuple\n    /// </summary>\n    public object Data { get; init; } = null!;\n\n    /// <summary>\n    /// If true, transformation failure throws exception.\n    /// If false, transformation failure returns input unchanged.\n    /// </summary>\n    public bool IsMandatory { get; init; } = true;\n\n    /// <summary>\n    /// Optional: The token name this operation applies to (for StringBuilder edits).\n    /// </summary>\n    public string? Token { get; init; }\n\n    /// <summary>\n    /// Optional: The output token name for derived values (for StringBuilder edits).\n    /// </summary>\n    public string? Output { get; init; }\n\n    /// <summary>\n    /// Applies this transformation operation to the input string.\n    /// </summary>\n    /// <param name=\"input\">The input string to transform.</param>\n    /// <param name=\"regexTimeout\">Optional regex timeout for Sub operations.</param>\n    /// <returns>The transformed string.</returns>\n    /// <exception cref=\"InvalidOperationException\">Thrown when IsMandatory=true and transformation fails.</exception>\n    public string Apply(string input, TimeSpan? regexTimeout = null)\n    {\n        try\n        {\n            return Action switch\n            {\n                TokenOperationAction.Sub => ApplySub(input, regexTimeout ?? TimeSpan.FromSeconds(1)),\n                TokenOperationAction.Lookup => ApplyLookup(input),\n                TokenOperationAction.Case => ApplyCase(input),\n                TokenOperationAction.LeftPad => ApplyLeftPad(input),\n                TokenOperationAction.NumberStyle => ApplyNumberStyle(input),\n                _ => throw new InvalidOperationException($\"Unknown action: {Action}\")\n            };\n        }\n        catch (Exception ex) when (!IsMandatory)\n        {\n            // Optional operation failed - return input unchanged\n            return input;\n        }\n    }\n\n    private string ApplySub(string input, TimeSpan timeout)\n    {\n        var (pattern, replacement) = ((string, string))Data;\n        var regex = new Regex(pattern, RegexOptions.None, timeout);\n        return regex.Replace(input, replacement);\n    }\n\n    private string ApplyLookup(string input)\n    {\n        var dict = (Dictionary<string, string>)Data;\n        \n        // Case-insensitive lookup\n        var key = dict.Keys.FirstOrDefault(k => \n            string.Equals(k, input, StringComparison.OrdinalIgnoreCase));\n        \n        if (key != null)\n        {\n            return dict[key];\n        }\n\n        if (IsMandatory)\n        {\n            throw new InvalidOperationException($\"Lookup key not found: '{input}'\");\n        }\n        \n        return input;\n    }\n\n    private string ApplyCase(string input)\n    {\n        var caseType = (string)Data;\n        \n        return caseType.ToLowerInvariant() switch\n        {\n            \"upper\" => input.ToUpperInvariant(),\n            \"lower\" => input.ToLowerInvariant(),\n            \"title\" => CultureInfo.CurrentCulture.TextInfo.ToTitleCase(input.ToLowerInvariant()),\n            _ => throw new InvalidOperationException($\"Unknown case type: {caseType}\")\n        };\n    }\n\n    private string ApplyLeftPad(string input)\n    {\n        var (padChar, totalWidth) = ((char, int))Data;\n        return input.PadLeft(totalWidth, padChar);\n    }\n\n    private string ApplyNumberStyle(string input)\n    {\n        var (fromStyle, toStyle) = ((string, string))Data;\n        \n        // First, convert input to integer\n        int number = fromStyle.ToLowerInvariant() switch\n        {\n            \"digit\" => int.Parse(input),\n            \"roman\" => RomanToInt(input),\n            \"cardinal\" => CardinalToInt(input),\n            \"ordinal\" => OrdinalToInt(input),\n            _ => throw new InvalidOperationException($\"Unknown from style: {fromStyle}\")\n        };\n\n        // Then convert integer to target style\n        return toStyle.ToLowerInvariant() switch\n        {\n            \"digit\" => number.ToString(),\n            \"roman\" => IntToRoman(number),\n            \"cardinal\" => IntToCardinal(number),\n            \"ordinal\" => IntToOrdinal(number),\n            _ => throw new InvalidOperationException($\"Unknown to style: {toStyle}\")\n        };\n    }\n\n    #region Number Style Conversion Helpers\n\n    private static readonly Dictionary<char, int> RomanValues = new()\n    {\n        ['I'] = 1, ['V'] = 5, ['X'] = 10, ['L'] = 50,\n        ['C'] = 100, ['D'] = 500, ['M'] = 1000\n    };\n\n    private static int RomanToInt(string roman)\n    {\n        roman = roman.ToUpperInvariant();\n        int result = 0;\n        int prevValue = 0;\n\n        for (int i = roman.Length - 1; i >= 0; i--)\n        {\n            int value = RomanValues[roman[i]];\n            if (value < prevValue)\n                result -= value;\n            else\n                result += value;\n            prevValue = value;\n        }\n\n        return result;\n    }\n\n    private static string IntToRoman(int number)\n    {\n        if (number < 1 || number > 100)\n            throw new ArgumentOutOfRangeException(nameof(number), \"Roman numerals only supported for 1-100\");\n\n        var romanNumerals = new (int value, string numeral)[]\n        {\n            (100, \"C\"), (90, \"XC\"), (50, \"L\"), (40, \"XL\"),\n            (10, \"X\"), (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\")\n        };\n\n        var result = new System.Text.StringBuilder();\n        foreach (var (value, numeral) in romanNumerals)\n        {\n            while (number >= value)\n            {\n                result.Append(numeral);\n                number -= value;\n            }\n        }\n        return result.ToString();\n    }\n\n    private static readonly string[] Cardinals = new[]\n    {\n        \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\",\n        \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\",\n        \"twenty\", \"twenty-one\", \"twenty-two\", \"twenty-three\", \"twenty-four\", \"twenty-five\", \"twenty-six\", \"twenty-seven\", \"twenty-eight\", \"twenty-nine\",\n        \"thirty\", \"thirty-one\", \"thirty-two\", \"thirty-three\", \"thirty-four\", \"thirty-five\", \"thirty-six\", \"thirty-seven\", \"thirty-eight\", \"thirty-nine\",\n        \"forty\", \"forty-one\", \"forty-two\", \"forty-three\", \"forty-four\", \"forty-five\", \"forty-six\", \"forty-seven\", \"forty-eight\", \"forty-nine\",\n        \"fifty\", \"fifty-one\", \"fifty-two\", \"fifty-three\", \"fifty-four\", \"fifty-five\", \"fifty-six\", \"fifty-seven\", \"fifty-eight\", \"fifty-nine\",\n        \"sixty\", \"sixty-one\", \"sixty-two\", \"sixty-three\", \"sixty-four\", \"sixty-five\", \"sixty-six\", \"sixty-seven\", \"sixty-eight\", \"sixty-nine\",\n        \"seventy\", \"seventy-one\", \"seventy-two\", \"seventy-three\", \"seventy-four\", \"seventy-five\", \"seventy-six\", \"seventy-seven\", \"seventy-eight\", \"seventy-nine\",\n        \"eighty\", \"eighty-one\", \"eighty-two\", \"eighty-three\", \"eighty-four\", \"eighty-five\", \"eighty-six\", \"eighty-seven\", \"eighty-eight\", \"eighty-nine\",\n        \"ninety\", \"ninety-one\", \"ninety-two\", \"ninety-three\", \"ninety-four\", \"ninety-five\", \"ninety-six\", \"ninety-seven\", \"ninety-eight\", \"ninety-nine\",\n        \"one hundred\"\n    };\n\n    private static readonly string[] Ordinals = new[]\n    {\n        \"zeroth\", \"first\", \"second\", \"third\", \"fourth\", \"fifth\", \"sixth\", \"seventh\", \"eighth\", \"ninth\",\n        \"tenth\", \"eleventh\", \"twelfth\", \"thirteenth\", \"fourteenth\", \"fifteenth\", \"sixteenth\", \"seventeenth\", \"eighteenth\", \"nineteenth\",\n        \"twentieth\", \"twenty-first\", \"twenty-second\", \"twenty-third\", \"twenty-fourth\", \"twenty-fifth\", \"twenty-sixth\", \"twenty-seventh\", \"twenty-eighth\", \"twenty-ninth\",\n        \"thirtieth\", \"thirty-first\", \"thirty-second\", \"thirty-third\", \"thirty-fourth\", \"thirty-fifth\", \"thirty-sixth\", \"thirty-seventh\", \"thirty-eighth\", \"thirty-ninth\",\n        \"fortieth\", \"forty-first\", \"forty-second\", \"forty-third\", \"forty-fourth\", \"forty-fifth\", \"forty-sixth\", \"forty-seventh\", \"forty-eighth\", \"forty-ninth\",\n        \"fiftieth\", \"fifty-first\", \"fifty-second\", \"fifty-third\", \"fifty-fourth\", \"fifty-fifth\", \"fifty-sixth\", \"fifty-seventh\", \"fifty-eighth\", \"fifty-ninth\",\n        \"sixtieth\", \"sixty-first\", \"sixty-second\", \"sixty-third\", \"sixty-fourth\", \"sixty-fifth\", \"sixty-sixth\", \"sixty-seventh\", \"sixty-eighth\", \"sixty-ninth\",\n        \"seventieth\", \"seventy-first\", \"seventy-second\", \"seventy-third\", \"seventy-fourth\", \"seventy-fifth\", \"seventy-sixth\", \"seventy-seventh\", \"seventy-eighth\", \"seventy-ninth\",\n        \"eightieth\", \"eighty-first\", \"eighty-second\", \"eighty-third\", \"eighty-fourth\", \"eighty-fifth\", \"eighty-sixth\", \"eighty-seventh\", \"eighty-eighth\", \"eighty-ninth\",\n        \"ninetieth\", \"ninety-first\", \"ninety-second\", \"ninety-third\", \"ninety-fourth\", \"ninety-fifth\", \"ninety-sixth\", \"ninety-seventh\", \"ninety-eighth\", \"ninety-ninth\",\n        \"one hundredth\"\n    };\n\n    private static int CardinalToInt(string cardinal)\n    {\n        var index = Array.FindIndex(Cardinals, c => \n            string.Equals(c, cardinal, StringComparison.OrdinalIgnoreCase));\n        \n        if (index == -1)\n            throw new InvalidOperationException($\"Unknown cardinal: {cardinal}\");\n        \n        return index;\n    }\n\n    private static string IntToCardinal(int number)\n    {\n        if (number < 0 || number > 100)\n            throw new ArgumentOutOfRangeException(nameof(number), \"Cardinals only supported for 0-100\");\n        \n        return Cardinals[number];\n    }\n\n    private static int OrdinalToInt(string ordinal)\n    {\n        var index = Array.FindIndex(Ordinals, o => \n            string.Equals(o, ordinal, StringComparison.OrdinalIgnoreCase));\n        \n        if (index == -1)\n            throw new InvalidOperationException($\"Unknown ordinal: {ordinal}\");\n        \n        return index;\n    }\n\n    private static string IntToOrdinal(int number)\n    {\n        if (number < 0 || number > 100)\n            throw new ArgumentOutOfRangeException(nameof(number), \"Ordinals only supported for 0-100\");\n        \n        return Ordinals[number];\n    }\n\n    #endregion\n}\n```\n\n#### STEP 2: Create TokenType Record\n\n**Create `src/CiteUrl.Core/Tokens/TokenType.cs`:**\n\n```csharp\nnamespace CiteUrl.Core.Tokens;\n\n/// <summary>\n/// Defines a token that can be captured from text and normalized.\n/// Immutable record representing token metadata and transformation pipeline.\n/// </summary>\npublic record TokenType\n{\n    /// <summary>\n    /// The regex pattern used to capture this token value.\n    /// </summary>\n    public string Regex { get; init; } = string.Empty;\n\n    /// <summary>\n    /// Ordered list of transformation operations to apply to captured values.\n    /// </summary>\n    public IReadOnlyList<TokenOperation> Edits { get; init; } = Array.Empty<TokenOperation>();\n\n    /// <summary>\n    /// Default value if token is not captured.\n    /// </summary>\n    public string? Default { get; init; }\n\n    /// <summary>\n    /// If true, this token can be truncated for authority matching.\n    /// Used for hierarchical tokens like subsections.\n    /// </summary>\n    public bool IsSeverable { get; init; }\n\n    /// <summary>\n    /// Normalizes a raw captured token value by applying the edit pipeline.\n    /// </summary>\n    /// <param name=\"rawValue\">The raw value captured by regex, or null.</param>\n    /// <param name=\"regexTimeout\">Optional regex timeout for edit operations.</param>\n    /// <returns>The normalized value, or Default if rawValue is null.</returns>\n    public string? Normalize(string? rawValue, TimeSpan? regexTimeout = null)\n    {\n        if (rawValue == null)\n            return Default;\n\n        var result = rawValue;\n        foreach (var edit in Edits)\n        {\n            result = edit.Apply(result, regexTimeout);\n        }\n\n        return result;\n    }\n}\n```\n\n#### STEP 3: Create Unit Tests\n\n**Create `tests/CiteUrl.Core.Tests/Tokens/TokenOperationTests.cs`:**\n\n```csharp\nusing CiteUrl.Core.Tokens;\nusing Shouldly;\nusing Xunit;\n\nnamespace CiteUrl.Core.Tests.Tokens;\n\npublic class TokenOperationTests\n{\n    [Fact]\n    public void Sub_ReplacesPatternWithReplacement()\n    {\n        // Arrange\n        var op = new TokenOperation\n        {\n            Action = TokenOperationAction.Sub,\n            Data = (@\"[.()]\", \"\")\n        };\n\n        // Act\n        var result = op.Apply(\"F. 2d (Test)\");\n\n        // Assert\n        result.ShouldBe(\"F 2d Test\");\n    }\n\n    [Fact]\n    public void Lookup_FindsKeysCaseInsensitively()\n    {\n        // Arrange\n        var dict = new Dictionary<string, string>\n        {\n            [\"f-2d\"] = \"f2d\",\n            [\"a-2d\"] = \"a2d\"\n        };\n        var op = new TokenOperation\n        {\n            Action = TokenOperationAction.Lookup,\n            Data = dict\n        };\n\n        // Act\n        var result = op.Apply(\"F-2D\");\n\n        // Assert\n        result.ShouldBe(\"f2d\");\n    }\n\n    [Fact]\n    public void Lookup_Mandatory_ThrowsWhenKeyNotFound()\n    {\n        // Arrange\n        var dict = new Dictionary<string, string> { [\"known\"] = \"value\" };\n        var op = new TokenOperation\n        {\n            Action = TokenOperationAction.Lookup,\n            Data = dict,\n            IsMandatory = true\n        };\n\n        // Act & Assert\n        Should.Throw<InvalidOperationException>(() => op.Apply(\"unknown\"));\n    }\n\n    [Fact]\n    public void Lookup_Optional_ReturnsInputWhenKeyNotFound()\n    {\n        // Arrange\n        var dict = new Dictionary<string, string> { [\"known\"] = \"value\" };\n        var op = new TokenOperation\n        {\n            Action = TokenOperationAction.Lookup,\n            Data = dict,\n            IsMandatory = false\n        };\n\n        // Act\n        var result = op.Apply(\"unknown\");\n\n        // Assert\n        result.ShouldBe(\"unknown\");\n    }\n\n    [Theory]\n    [InlineData(\"upper\", \"hello world\", \"HELLO WORLD\")]\n    [InlineData(\"lower\", \"HELLO WORLD\", \"hello world\")]\n    [InlineData(\"title\", \"hello world\", \"Hello World\")]\n    public void Case_TransformsCorrectly(string caseType, string input, string expected)\n    {\n        // Arrange\n        var op = new TokenOperation\n        {\n            Action = TokenOperationAction.Case,\n            Data = caseType\n        };\n\n        // Act\n        var result = op.Apply(input);\n\n        // Assert\n        result.ShouldBe(expected);\n    }\n\n    [Fact]\n    public void LeftPad_PadsToCorrectWidth()\n    {\n        // Arrange\n        var op = new TokenOperation\n        {\n            Action = TokenOperationAction.LeftPad,\n            Data = ('0', 5)\n        };\n\n        // Act\n        var result = op.Apply(\"42\");\n\n        // Assert\n        result.ShouldBe(\"00042\");\n    }\n\n    [Theory]\n    [InlineData(\"digit\", \"roman\", \"5\", \"V\")]\n    [InlineData(\"digit\", \"roman\", \"42\", \"XLII\")]\n    [InlineData(\"roman\", \"digit\", \"X\", \"10\")]\n    [InlineData(\"roman\", \"digit\", \"XCIX\", \"99\")]\n    [InlineData(\"digit\", \"cardinal\", \"5\", \"five\")]\n    [InlineData(\"cardinal\", \"digit\", \"forty-two\", \"42\")]\n    [InlineData(\"digit\", \"ordinal\", \"5\", \"fifth\")]\n    [InlineData(\"ordinal\", \"digit\", \"forty-second\", \"42\")]\n    public void NumberStyle_ConvertsCorrectly(string from, string to, string input, string expected)\n    {\n        // Arrange\n        var op = new TokenOperation\n        {\n            Action = TokenOperationAction.NumberStyle,\n            Data = (from, to)\n        };\n\n        // Act\n        var result = op.Apply(input);\n\n        // Assert\n        result.ShouldBe(expected, StringCompareShould.IgnoreCase);\n    }\n\n    [Fact]\n    public void NumberStyle_SupportsRange1To100()\n    {\n        // Arrange\n        var op = new TokenOperation\n        {\n            Action = TokenOperationAction.NumberStyle,\n            Data = (\"digit\", \"roman\")\n        };\n\n        // Act & Assert\n        op.Apply(\"1\").ShouldBe(\"I\");\n        op.Apply(\"100\").ShouldBe(\"C\");\n    }\n}\n```\n\n**Create `tests/CiteUrl.Core.Tests/Tokens/TokenTypeTests.cs`:**\n\n```csharp\nusing CiteUrl.Core.Tokens;\nusing Shouldly;\nusing Xunit;\n\nnamespace CiteUrl.Core.Tests.Tokens;\n\npublic class TokenTypeTests\n{\n    [Fact]\n    public void Normalize_AppliesEditPipelineInOrder()\n    {\n        // Arrange\n        var tokenType = new TokenType\n        {\n            Regex = @\".*\",\n            Edits = new[]\n            {\n                new TokenOperation { Action = TokenOperationAction.Case, Data = \"lower\" },\n                new TokenOperation { Action = TokenOperationAction.Sub, Data = (@\"[.()]\", \"\") },\n                new TokenOperation \n                { \n                    Action = TokenOperationAction.Lookup,\n                    Data = new Dictionary<string, string> { [\"f 2d\"] = \"f2d\" },\n                    IsMandatory = false\n                }\n            }\n        };\n\n        // Act\n        var result = tokenType.Normalize(\"F. 2d\");\n\n        // Assert\n        result.ShouldBe(\"f2d\");\n    }\n\n    [Fact]\n    public void Normalize_ReturnsDefaultWhenInputIsNull()\n    {\n        // Arrange\n        var tokenType = new TokenType\n        {\n            Default = \"default-value\",\n            Edits = Array.Empty<TokenOperation>()\n        };\n\n        // Act\n        var result = tokenType.Normalize(null);\n\n        // Assert\n        result.ShouldBe(\"default-value\");\n    }\n\n    [Fact]\n    public void Normalize_PropagatesExceptionsFromMandatoryOperations()\n    {\n        // Arrange\n        var tokenType = new TokenType\n        {\n            Edits = new[]\n            {\n                new TokenOperation\n                {\n                    Action = TokenOperationAction.Lookup,\n                    Data = new Dictionary<string, string> { [\"known\"] = \"value\" },\n                    IsMandatory = true\n                }\n            }\n        };\n\n        // Act & Assert\n        Should.Throw<InvalidOperationException>(() => tokenType.Normalize(\"unknown\"));\n    }\n}\n```\n\n#### STEP 4: Build and Run Tests\n\n```bash\ndotnet build\ndotnet test --verbosity normal\n```\n\nVerify all tests pass (should see ~15 tests passing).\n\n### Verification Checklist\n- [ ] TokenOperation record implements all 5 action types\n- [ ] Number style conversion works for 1-100 (roman, cardinal, ordinal, digit)\n- [ ] Lookup tables are case-insensitive\n- [ ] Mandatory operations throw on failure\n- [ ] Optional operations return input unchanged on failure\n- [ ] TokenType applies edit pipeline in order\n- [ ] All unit tests pass (15+ tests)\n- [ ] 100% code coverage for token operations\n\n### Post-Task Actions\nNone - proceed to Task 1.3",

  "successCriteria": [
    "TokenOperation record created with all 5 action types (Sub, Lookup, Case, LeftPad, NumberStyle)",
    "Number style conversion supports full range 1-100 for all four formats",
    "Lookup operations are case-insensitive as verified by tests",
    "Mandatory flag correctly controls exception vs. silent failure behavior",
    "TokenType.Normalize() applies edit pipeline in correct sequence",
    "All 15+ unit tests pass without errors",
    "Code compiles without warnings",
    "Test coverage >90% for TokenOperation and TokenType classes"
  ],

  "pauseAndAskScenarios": [
    "If number style conversion patterns are unclear beyond documented range",
    "If YAML deserialization format conflicts with TokenOperation structure"
  ],

  "executionControls": {
    "scopeAndBoundaries": {
      "mustImplement": [
        "All 5 TokenOperationAction types",
        "Number style conversion for 1-100",
        "Case-insensitive lookup tables",
        "Mandatory vs. optional operation handling",
        "Immutable record types for both TokenOperation and TokenType"
      ],
      "mustNotImplement": [
        "Do not add mutable state to records",
        "Do not skip regex timeout parameter support",
        "Do not implement number conversion beyond 0-100 range"
      ],
      "flexible": [
        "Exact exception message wording",
        "Internal helper method names",
        "Test organization and naming"
      ]
    },
    "riskFactors": [
      {
        "risk": "Number word arrays may have typos",
        "mitigation": "Copy cardinal/ordinal arrays carefully, verify with tests",
        "severity": "medium"
      },
      {
        "risk": "Regex timeout not propagated through pipeline",
        "mitigation": "Pass timeout parameter through all Apply() calls",
        "severity": "low"
      }
    ],
    "qualityGates": [
      "All tests must pass",
      "No compilation warnings",
      "Test coverage >90% for token classes"
    ]
  },

  "associatedArtifacts": [
    {
      "type": "source_file",
      "path": "src/CiteUrl.Core/Tokens/TokenOperation.cs",
      "description": "Immutable record implementing 5 token transformation operations"
    },
    {
      "type": "source_file",
      "path": "src/CiteUrl.Core/Tokens/TokenType.cs",
      "description": "Immutable record for token definitions with normalization pipeline"
    },
    {
      "type": "test_file",
      "path": "tests/CiteUrl.Core.Tests/Tokens/TokenOperationTests.cs",
      "description": "Unit tests for all TokenOperation action types"
    },
    {
      "type": "test_file",
      "path": "tests/CiteUrl.Core.Tests/Tokens/TokenTypeTests.cs",
      "description": "Unit tests for TokenType normalization pipeline"
    }
  ]
}
