{
  "id": "2.2",
  "title": "YAML Template Deserialization",
  "objective": "Load templates from YAML files using YamlDotNet with support for template inheritance, anchors/aliases, and conversion to Template objects",
  "complexity": "complex",
  "phaseId": "2",
  "taskNumber": 2,
  "totalTasksInPhase": 3,

  "metadata": {
    "taskType": "implementation",
    "estimatedDuration": "5-7 hours",
    "dependencies": ["2.1"],
    "requiredContext": [
      "Template class from Task 2.1",
      "TokenType and TokenOperation from Phase 1",
      "Error handling decision from gap analysis (hybrid approach)"
    ],
    "skillLevel": "advanced"
  },

  "contextManagement": {
    "isFirstInPhase": false,
    "isLastInPhase": false,
    "requiredContext": [
      "Template class structure",
      "TokenType and TokenOperation classes",
      "StringBuilder class",
      "Gap Decision #1: Hybrid error handling (strict YAML loading)"
    ],
    "contextToPreserve": [
      "YamlLoader static class",
      "YAML deserialization models (TemplateYaml, TokenTypeYaml, etc.)",
      "Template inheritance resolution order",
      "Exception handling for YAML errors"
    ]
  },

  "criticalAnchors": [
    "IMMUTABLE: Use YamlDotNet deserializer with custom type converters",
    "IMMUTABLE: Support YAML anchors and aliases",
    "IMMUTABLE: Template inheritance via 'inherit' key",
    "IMMUTABLE: YAML errors throw CiteUrlYamlException (Gap Decision #1: strict loading)",
    "IMMUTABLE: Support singular/plural key forms (pattern vs. patterns)",
    "IMMUTABLE: Preserve template order for inheritance resolution",
    "IMMUTABLE: Key normalization: spaces â†’ underscores"
  ],

  "agentInstructions": "## Task 2.2: YAML Template Deserialization\n\n### Overview\nYou will implement YAML loading using YamlDotNet to deserialize template files into Template objects.\n\n### Step-by-Step Instructions\n\n#### STEP 1: Create Custom Exception Types\n\n**Create `src/CiteUrl.Core/Exceptions/CiteUrlException.cs`:**\n\n```csharp\nnamespace CiteUrl.Core.Exceptions;\n\n/// <summary>\n/// Base exception for CiteUrl library errors.\n/// </summary>\npublic class CiteUrlException : Exception\n{\n    public CiteUrlException(string message) : base(message) { }\n    public CiteUrlException(string message, Exception innerException) \n        : base(message, innerException) { }\n}\n\n/// <summary>\n/// Exception thrown when YAML parsing or deserialization fails.\n/// </summary>\npublic class CiteUrlYamlException : CiteUrlException\n{\n    public string? YamlFileName { get; init; }\n    public int? LineNumber { get; init; }\n\n    public CiteUrlYamlException(string message) : base(message) { }\n    \n    public CiteUrlYamlException(string message, Exception innerException) \n        : base(message, innerException) { }\n\n    public CiteUrlYamlException(string message, string? yamlFileName, int? lineNumber = null) \n        : base(message)\n    {\n        YamlFileName = yamlFileName;\n        LineNumber = lineNumber;\n    }\n}\n\n/// <summary>\n/// Exception thrown when regex compilation fails.\n/// </summary>\npublic class CiteUrlRegexException : CiteUrlException\n{\n    public string? TemplateName { get; init; }\n    public string? Pattern { get; init; }\n\n    public CiteUrlRegexException(string message) : base(message) { }\n    \n    public CiteUrlRegexException(string message, Exception innerException) \n        : base(message, innerException) { }\n\n    public CiteUrlRegexException(string message, string? templateName, string? pattern = null) \n        : base(message)\n    {\n        TemplateName = templateName;\n        Pattern = pattern;\n    }\n}\n\n/// <summary>\n/// Exception thrown when token normalization fails.\n/// </summary>\npublic class CiteUrlTokenException : CiteUrlException\n{\n    public string? TokenName { get; init; }\n    public string? InputValue { get; init; }\n\n    public CiteUrlTokenException(string message) : base(message) { }\n    \n    public CiteUrlTokenException(string message, Exception innerException) \n        : base(message, innerException) { }\n\n    public CiteUrlTokenException(string message, string? tokenName, string? inputValue = null) \n        : base(message)\n    {\n        TokenName = tokenName;\n        InputValue = inputValue;\n    }\n}\n```\n\n#### STEP 2: Create YAML Deserialization Models\n\n**Create `src/CiteUrl.Core/Utilities/YamlModels.cs`:**\n\n```csharp\nusing YamlDotNet.Serialization;\n\nnamespace CiteUrl.Core.Utilities;\n\n/// <summary>\n/// YAML deserialization model for templates.\n/// All properties nullable to support template inheritance.\n/// </summary>\npublic class TemplateYaml\n{\n    [YamlMember(Alias = \"tokens\")]\n    public Dictionary<string, TokenTypeYaml>? Tokens { get; set; }\n\n    [YamlMember(Alias = \"meta\")]\n    public Dictionary<string, string>? Meta { get; set; }\n\n    [YamlMember(Alias = \"pattern\")]\n    public string? Pattern { get; set; }\n\n    [YamlMember(Alias = \"patterns\")]\n    public List<string>? Patterns { get; set; }\n\n    [YamlMember(Alias = \"broad pattern\")]\n    public string? BroadPattern { get; set; }\n\n    [YamlMember(Alias = \"broad patterns\")]\n    public List<string>? BroadPatterns { get; set; }\n\n    [YamlMember(Alias = \"shortform pattern\")]\n    public string? ShortformPattern { get; set; }\n\n    [YamlMember(Alias = \"shortform patterns\")]\n    public List<string>? ShortformPatterns { get; set; }\n\n    [YamlMember(Alias = \"idform pattern\")]\n    public string? IdformPattern { get; set; }\n\n    [YamlMember(Alias = \"idform patterns\")]\n    public List<string>? IdformPatterns { get; set; }\n\n    [YamlMember(Alias = \"URL builder\")]\n    public StringBuilderYaml? UrlBuilder { get; set; }\n\n    [YamlMember(Alias = \"name builder\")]\n    public StringBuilderYaml? NameBuilder { get; set; }\n\n    [YamlMember(Alias = \"inherit\")]\n    public string? Inherit { get; set; }\n\n    /// <summary>\n    /// Combines singular and plural pattern forms.\n    /// </summary>\n    public List<string> GetPatterns()\n    {\n        var result = new List<string>();\n        if (Pattern != null) result.Add(Pattern);\n        if (Patterns != null) result.AddRange(Patterns);\n        return result;\n    }\n\n    public List<string> GetBroadPatterns()\n    {\n        var result = new List<string>();\n        if (BroadPattern != null) result.Add(BroadPattern);\n        if (BroadPatterns != null) result.AddRange(BroadPatterns);\n        return result;\n    }\n\n    public List<string> GetShortformPatterns()\n    {\n        var result = new List<string>();\n        if (ShortformPattern != null) result.Add(ShortformPattern);\n        if (ShortformPatterns != null) result.AddRange(ShortformPatterns);\n        return result;\n    }\n\n    public List<string> GetIdformPatterns()\n    {\n        var result = new List<string>();\n        if (IdformPattern != null) result.Add(IdformPattern);\n        if (IdformPatterns != null) result.AddRange(IdformPatterns);\n        return result;\n    }\n}\n\npublic class TokenTypeYaml\n{\n    [YamlMember(Alias = \"regex\")]\n    public string? Regex { get; set; }\n\n    [YamlMember(Alias = \"edit\")]\n    public object? Edit { get; set; }\n\n    [YamlMember(Alias = \"edits\")]\n    public List<object>? Edits { get; set; }\n\n    [YamlMember(Alias = \"default\")]\n    public string? Default { get; set; }\n\n    [YamlMember(Alias = \"severable\")]\n    public bool? Severable { get; set; }\n\n    public List<object> GetEdits()\n    {\n        var result = new List<object>();\n        if (Edit != null) result.Add(Edit);\n        if (Edits != null) result.AddRange(Edits);\n        return result;\n    }\n}\n\npublic class StringBuilderYaml\n{\n    [YamlMember(Alias = \"part\")]\n    public string? Part { get; set; }\n\n    [YamlMember(Alias = \"parts\")]\n    public List<string>? Parts { get; set; }\n\n    [YamlMember(Alias = \"edit\")]\n    public object? Edit { get; set; }\n\n    [YamlMember(Alias = \"edits\")]\n    public List<object>? Edits { get; set; }\n\n    public List<string> GetParts()\n    {\n        var result = new List<string>();\n        if (Part != null) result.Add(Part);\n        if (Parts != null) result.AddRange(Parts);\n        return result;\n    }\n\n    public List<object> GetEdits()\n    {\n        var result = new List<object>();\n        if (Edit != null) result.Add(Edit);\n        if (Edits != null) result.AddRange(Edits);\n        return result;\n    }\n}\n```\n\n#### STEP 3: Create YamlLoader Utility\n\n**Create `src/CiteUrl.Core/Utilities/YamlLoader.cs`:**\n\n```csharp\nusing System.Collections.Immutable;\nusing YamlDotNet.Serialization;\nusing YamlDotNet.Serialization.NamingConventions;\nusing CiteUrl.Core.Templates;\nusing CiteUrl.Core.Tokens;\nusing CiteUrl.Core.Exceptions;\nusing Serilog;\n\nnamespace CiteUrl.Core.Utilities;\n\n/// <summary>\n/// Loads templates from YAML content.\n/// </summary>\npublic static class YamlLoader\n{\n    private static readonly ILogger? Logger = Log.Logger;\n\n    /// <summary>\n    /// Loads templates from YAML content string.\n    /// </summary>\n    /// <param name=\"yamlContent\">YAML content to parse.</param>\n    /// <param name=\"fileName\">Optional filename for error reporting.</param>\n    /// <returns>Dictionary of template name to Template object.</returns>\n    /// <exception cref=\"CiteUrlYamlException\">Thrown when YAML parsing fails.</exception>\n    public static Dictionary<string, Template> LoadYaml(string yamlContent, string? fileName = null)\n    {\n        try\n        {\n            // Deserialize YAML to intermediate models\n            var deserializer = new DeserializerBuilder()\n                .WithNamingConvention(UnderscoredNamingConvention.Instance)\n                .Build();\n\n            var yamlTemplates = deserializer.Deserialize<Dictionary<string, TemplateYaml>>(yamlContent);\n\n            if (yamlTemplates == null)\n            {\n                throw new CiteUrlYamlException(\"YAML deserialization returned null\", fileName);\n            }\n\n            // Convert to Template objects with inheritance resolution\n            return ConvertTemplates(yamlTemplates, fileName);\n        }\n        catch (YamlDotNet.Core.YamlException ex)\n        {\n            Logger?.Error(ex, \"YAML parsing failed for {FileName}\", fileName ?? \"<unknown>\");\n            throw new CiteUrlYamlException(\n                $\"YAML parsing error: {ex.Message}\",\n                fileName,\n                ex.Start.Line);\n        }\n        catch (CiteUrlYamlException)\n        {\n            throw; // Re-throw our custom exceptions\n        }\n        catch (Exception ex)\n        {\n            Logger?.Error(ex, \"Unexpected error loading YAML from {FileName}\", fileName ?? \"<unknown>\");\n            throw new CiteUrlYamlException(\n                $\"Error loading templates: {ex.Message}\",\n                fileName);\n        }\n    }\n\n    private static Dictionary<string, Template> ConvertTemplates(\n        Dictionary<string, TemplateYaml> yamlTemplates,\n        string? fileName)\n    {\n        var templates = new Dictionary<string, Template>();\n        var processed = new HashSet<string>();\n\n        // Process templates in dependency order (resolve inheritance)\n        foreach (var (name, _) in yamlTemplates)\n        {\n            ProcessTemplate(name, yamlTemplates, templates, processed, fileName);\n        }\n\n        return templates;\n    }\n\n    private static void ProcessTemplate(\n        string name,\n        Dictionary<string, TemplateYaml> yamlTemplates,\n        Dictionary<string, Template> templates,\n        HashSet<string> processed,\n        string? fileName)\n    {\n        // Already processed\n        if (processed.Contains(name))\n            return;\n\n        var yaml = yamlTemplates[name];\n\n        // Process parent first if inheritance specified\n        Template? parent = null;\n        if (yaml.Inherit != null)\n        {\n            if (!yamlTemplates.ContainsKey(yaml.Inherit))\n            {\n                throw new CiteUrlYamlException(\n                    $\"Template '{name}' inherits from unknown template '{yaml.Inherit}'\",\n                    fileName);\n            }\n\n            ProcessTemplate(yaml.Inherit, yamlTemplates, templates, processed, fileName);\n            parent = templates[yaml.Inherit];\n        }\n\n        // Convert YAML to Template\n        try\n        {\n            var template = ConvertTemplate(name, yaml, parent, fileName);\n            templates[name] = template;\n            processed.Add(name);\n\n            Logger?.Information(\"Loaded template: {TemplateName}\", name);\n        }\n        catch (Exception ex) when (ex is not CiteUrlYamlException)\n        {\n            throw new CiteUrlYamlException(\n                $\"Error converting template '{name}': {ex.Message}\",\n                fileName);\n        }\n    }\n\n    private static Template ConvertTemplate(\n        string name,\n        TemplateYaml yaml,\n        Template? parent,\n        string? fileName)\n    {\n        // Convert tokens\n        var tokens = ImmutableDictionary<string, TokenType>.Empty;\n        if (yaml.Tokens != null)\n        {\n            foreach (var (tokenName, tokenYaml) in yaml.Tokens)\n            {\n                tokens = tokens.Add(tokenName, ConvertTokenType(tokenYaml));\n            }\n        }\n\n        // Convert metadata\n        var metadata = yaml.Meta != null\n            ? yaml.Meta.ToImmutableDictionary()\n            : ImmutableDictionary<string, string>.Empty;\n\n        // Convert builders\n        var urlBuilder = yaml.UrlBuilder != null\n            ? ConvertStringBuilder(yaml.UrlBuilder, isUrl: true)\n            : null;\n\n        var nameBuilder = yaml.NameBuilder != null\n            ? ConvertStringBuilder(yaml.NameBuilder, isUrl: false)\n            : null;\n\n        // If parent exists, use inheritance\n        if (parent != null)\n        {\n            return Template.Inherit(\n                parent,\n                name: name,\n                tokens: tokens.Count > 0 ? tokens : null,\n                metadata: metadata.Count > 0 ? metadata : null,\n                patterns: yaml.GetPatterns(),\n                broadPatterns: yaml.GetBroadPatterns(),\n                shortformPatterns: yaml.GetShortformPatterns(),\n                idformPatterns: yaml.GetIdformPatterns(),\n                urlBuilder: urlBuilder,\n                nameBuilder: nameBuilder\n            );\n        }\n\n        // Create new template\n        return new Template(\n            name: name,\n            tokens: tokens,\n            metadata: metadata,\n            patterns: yaml.GetPatterns(),\n            broadPatterns: yaml.GetBroadPatterns(),\n            shortformPatterns: yaml.GetShortformPatterns(),\n            idformPatterns: yaml.GetIdformPatterns(),\n            urlBuilder: urlBuilder,\n            nameBuilder: nameBuilder\n        );\n    }\n\n    private static TokenType ConvertTokenType(TokenTypeYaml yaml)\n    {\n        var edits = new List<TokenOperation>();\n        foreach (var editObj in yaml.GetEdits())\n        {\n            edits.Add(ConvertTokenOperation(editObj));\n        }\n\n        return new TokenType\n        {\n            Regex = yaml.Regex ?? string.Empty,\n            Edits = edits,\n            Default = yaml.Default,\n            IsSeverable = yaml.Severable ?? false\n        };\n    }\n\n    private static TokenOperation ConvertTokenOperation(object editObj)\n    {\n        // Edit can be a dictionary with action keys\n        if (editObj is Dictionary<object, object> dict)\n        {\n            var strDict = dict.ToDictionary(kv => kv.Key.ToString()!, kv => kv.Value);\n\n            if (strDict.ContainsKey(\"sub\"))\n            {\n                var subData = (List<object>)strDict[\"sub\"];\n                return new TokenOperation\n                {\n                    Action = TokenOperationAction.Sub,\n                    Data = (subData[0].ToString()!, subData[1].ToString()!),\n                    Token = strDict.GetValueOrDefault(\"token\")?.ToString(),\n                    Output = strDict.GetValueOrDefault(\"output\")?.ToString(),\n                    IsMandatory = strDict.GetValueOrDefault(\"mandatory\") as bool? ?? true\n                };\n            }\n\n            if (strDict.ContainsKey(\"lookup\"))\n            {\n                var lookupDict = ((Dictionary<object, object>)strDict[\"lookup\"])\n                    .ToDictionary(kv => kv.Key.ToString()!, kv => kv.Value.ToString()!);\n                \n                return new TokenOperation\n                {\n                    Action = TokenOperationAction.Lookup,\n                    Data = lookupDict,\n                    Token = strDict.GetValueOrDefault(\"token\")?.ToString(),\n                    IsMandatory = strDict.GetValueOrDefault(\"mandatory\") as bool? ?? true\n                };\n            }\n\n            if (strDict.ContainsKey(\"case\"))\n            {\n                return new TokenOperation\n                {\n                    Action = TokenOperationAction.Case,\n                    Data = strDict[\"case\"].ToString()!,\n                    Token = strDict.GetValueOrDefault(\"token\")?.ToString()\n                };\n            }\n\n            if (strDict.ContainsKey(\"lpad\"))\n            {\n                var lpadData = (List<object>)strDict[\"lpad\"];\n                return new TokenOperation\n                {\n                    Action = TokenOperationAction.LeftPad,\n                    Data = (lpadData[0].ToString()![0], Convert.ToInt32(lpadData[1])),\n                    Token = strDict.GetValueOrDefault(\"token\")?.ToString()\n                };\n            }\n\n            if (strDict.ContainsKey(\"number_style\"))\n            {\n                var nsData = (List<object>)strDict[\"number_style\"];\n                return new TokenOperation\n                {\n                    Action = TokenOperationAction.NumberStyle,\n                    Data = (nsData[0].ToString()!, nsData[1].ToString()!),\n                    Token = strDict.GetValueOrDefault(\"token\")?.ToString()\n                };\n            }\n        }\n\n        throw new InvalidOperationException($\"Unknown edit operation format: {editObj}\");\n    }\n\n    private static CiteUrl.Core.Tokens.StringBuilder ConvertStringBuilder(\n        StringBuilderYaml yaml,\n        bool isUrl)\n    {\n        var edits = new List<TokenOperation>();\n        foreach (var editObj in yaml.GetEdits())\n        {\n            edits.Add(ConvertTokenOperation(editObj));\n        }\n\n        return new CiteUrl.Core.Tokens.StringBuilder\n        {\n            Parts = yaml.GetParts(),\n            Edits = edits,\n            UrlEncode = isUrl\n        };\n    }\n}\n```\n\n#### STEP 4: Create Unit Tests\n\n**Create `tests/CiteUrl.Core.Tests/Utilities/YamlLoaderTests.cs`:**\n\n```csharp\nusing CiteUrl.Core.Utilities;\nusing CiteUrl.Core.Exceptions;\nusing Shouldly;\nusing Xunit;\n\nnamespace CiteUrl.Core.Tests.Utilities;\n\npublic class YamlLoaderTests\n{\n    [Fact]\n    public void LoadYaml_ParsesSimpleTemplate()\n    {\n        // Arrange\n        var yaml = @\"\nTest Template:\n  tokens:\n    title:\n      regex: \\d+\n  pattern: '{title} U.S.C.'\n\";\n\n        // Act\n        var templates = YamlLoader.LoadYaml(yaml);\n\n        // Assert\n        templates.Count.ShouldBe(1);\n        templates.ContainsKey(\"Test Template\").ShouldBeTrue();\n        var template = templates[\"Test Template\"];\n        template.Tokens.Count.ShouldBe(1);\n        template.Regexes.Count.ShouldBe(1);\n    }\n\n    [Fact]\n    public void LoadYaml_SupportsTemplateInheritance()\n    {\n        // Arrange\n        var yaml = @\"\nParent:\n  tokens:\n    token1:\n      regex: parent1\n  pattern: 'parent pattern'\n\nChild:\n  inherit: Parent\n  tokens:\n    token2:\n      regex: child2\n  pattern: 'child pattern'\n\";\n\n        // Act\n        var templates = YamlLoader.LoadYaml(yaml);\n\n        // Assert\n        templates.Count.ShouldBe(2);\n        var child = templates[\"Child\"];\n        child.Tokens.Count.ShouldBe(2); // Inherited + new\n        child.Tokens.ContainsKey(\"token1\").ShouldBeTrue();\n        child.Tokens.ContainsKey(\"token2\").ShouldBeTrue();\n    }\n\n    [Fact]\n    public void LoadYaml_ThrowsOnInvalidYaml()\n    {\n        // Arrange\n        var invalidYaml = @\"\nBad YAML:\n  - this is\n    invalid: [syntax\n\";\n\n        // Act & Assert\n        Should.Throw<CiteUrlYamlException>(() => YamlLoader.LoadYaml(invalidYaml));\n    }\n\n    [Fact]\n    public void LoadYaml_ThrowsOnUnknownParent()\n    {\n        // Arrange\n        var yaml = @\"\nChild:\n  inherit: NonExistent\n  pattern: 'test'\n\";\n\n        // Act & Assert\n        var ex = Should.Throw<CiteUrlYamlException>(() => YamlLoader.LoadYaml(yaml));\n        ex.Message.ShouldContain(\"NonExistent\");\n    }\n\n    [Fact]\n    public void LoadYaml_SupportsSingularAndPluralKeys()\n    {\n        // Arrange\n        var yaml = @\"\nTemplate1:\n  pattern: 'single pattern'\n\nTemplate2:\n  patterns:\n    - 'pattern 1'\n    - 'pattern 2'\n\";\n\n        // Act\n        var templates = YamlLoader.LoadYaml(yaml);\n\n        // Assert\n        templates[\"Template1\"].Regexes.Count.ShouldBe(1);\n        templates[\"Template2\"].Regexes.Count.ShouldBe(2);\n    }\n}\n```\n\n#### STEP 5: Build and Run Tests\n\n```bash\ndotnet build\ndotnet test --verbosity normal\n```\n\n### Verification Checklist\n- [ ] YamlDotNet deserializes all template structures\n- [ ] Template inheritance resolves correctly\n- [ ] CiteUrlYamlException thrown on YAML errors (Gap Decision #1)\n- [ ] YAML anchors/aliases work\n- [ ] Singular/plural key forms supported\n- [ ] All 5+ YAML loader tests pass\n\n### Post-Task Actions\nNone - proceed to Task 2.3",

  "successCriteria": [
    "Custom exception types created (CiteUrlYamlException, CiteUrlRegexException, CiteUrlTokenException)",
    "YamlDotNet deserializes YAML to intermediate models successfully",
    "Template inheritance resolves in correct dependency order",
    "YAML parsing errors throw CiteUrlYamlException with file/line info",
    "Singular and plural pattern keys both supported (pattern vs patterns)",
    "Token operations convert correctly from YAML",
    "StringBuilder converts correctly from YAML",
    "All 5+ YamlLoader tests pass",
    "Serilog logging integrated for YAML loading events"
  ],

  "pauseAndAskScenarios": [
    "If YAML deserialization format conflicts with YamlDotNet structure",
    "If template inheritance creates circular dependencies"
  ],

  "executionControls": {
    "scopeAndBoundaries": {
      "mustImplement": [
        "Custom exception hierarchy for error handling",
        "YamlDotNet integration with proper configuration",
        "Template inheritance resolution algorithm",
        "Support for singular/plural YAML keys",
        "Strict YAML loading (throw on errors)",
        "Serilog logging for template loading"
      ],
      "mustNotImplement": [
        "Do not silently ignore YAML errors",
        "Do not skip template inheritance",
        "Do not use lenient error handling for YAML (strict only)"
      ],
      "flexible": [
        "Internal conversion method structure",
        "Exact error message wording",
        "Test YAML examples"
      ]
    },
    "riskFactors": [
      {
        "risk": "YamlDotNet deserialization may fail on complex structures",
        "mitigation": "Test with real YAML files incrementally",
        "severity": "high"
      },
      {
        "risk": "Template inheritance could create circular dependencies",
        "mitigation": "Track processed templates, detect cycles",
        "severity": "medium"
      }
    ],
    "qualityGates": [
      "All tests must pass",
      "YAML errors must throw CiteUrlYamlException",
      "Template inheritance must resolve correctly"
    ]
  },

  "associatedArtifacts": [
    {
      "type": "source_file",
      "path": "src/CiteUrl.Core/Exceptions/CiteUrlException.cs",
      "description": "Custom exception hierarchy for error handling"
    },
    {
      "type": "source_file",
      "path": "src/CiteUrl.Core/Utilities/YamlModels.cs",
      "description": "YAML deserialization model classes"
    },
    {
      "type": "source_file",
      "path": "src/CiteUrl.Core/Utilities/YamlLoader.cs",
      "description": "YAML loading and template conversion logic"
    },
    {
      "type": "test_file",
      "path": "tests/CiteUrl.Core.Tests/Utilities/YamlLoaderTests.cs",
      "description": "Unit tests for YAML loading functionality"
    }
  ]
}
